[{"authors":null,"categories":null,"content":"Qu\u0026rsquo;est-ce que FMT ? Dans sa forme la plus basique, FMT est une librairie open source de fonctions et d\u0026rsquo;objets que vous pouvez utiliser dans diff√©rents langages de programmation: C++, R ou Python.\nLes fonctions et les objets de FMT sont utilis√©s pour faire de la planification foresti√®re. La planification foresti√®re r√©pond √† la question de comment un paysage forestier doit √™tre trait√© afin de maximiser certains objectifs (par exemple, le rendement √©conomique), et sous certaines contraintes (par exemple, les objectifs √©cologiques et de conservation, la l√©gislation, les limites op√©rationnelles, etc.).\nConcr√®tement, FMT vous permet de :\nLire les mod√®les de planification foresti√®re bas√©s sur le format de fichiers Woodstock (qui sont des mod√®les de programmation lin√©aire de type III r√©f√©renc√©s spatialement) Modifier ces mod√®les de planification foresti√®re R√©soudre ces mod√®les de planification foresti√®re (c\u0026rsquo;est-√†-dire g√©n√©rer un calendrier d\u0026rsquo;actions qui maximisent les objectifs et respectent les contraintes) Rendre les variables de peuplements et le calendrier optimis√© spatialement explicite (c\u0026rsquo;est-√†-dire cartographier les op√©rations foresti√®res) √Ä quoi sert-il principalement ? Lecture de mod√®les Woodstock Simulation de paysages forestiers Optimisation / R√©optimisation de mod√®les Replanification (en utilisant des √©v√©nements stochastiques) R√©solution des heuristiques d\u0026rsquo;agr√©gation Planification des blocs de r√©colte Comment est-ce que √ßa marche techniquement ? Le code source des fonctions dans FMT est √©crit dans le langage C++.\nCependant, il est con√ßu pour √™tre compil√© dans diff√©rents formats de librairies de fonctions pouvant √™tre utilis√©s en langage Python et R.\ngraph TD;\r1--\u0026gt;2;\r1--\u0026gt;3;\r1--\u0026gt;4;\r1[\u0026quot;Interface de programmation (C++)\u0026quot;]\r2[\u0026quot;Python 2\u0026quot;]\r3[\u0026quot;Python 3\u0026quot;]\r4[\u0026quot;Cran R\u0026quot;]\rPourquoi a-t-il √©t√© concu ? Le projet FMT a d√©but√© en 2017, au Bureau du forestier en chef (BFEC) du Qu√©bec.\n√âtant donn√© que le BFEC utilisait des mod√®les Woodstock tous les jours, il √©tait n√©cessaire d\u0026rsquo;avoir des scripts r√©plicables permettant aux analystes de lire et d\u0026rsquo;√©diter automatiquement les fichiers de mod√®les Woodstock sans utiliser l\u0026rsquo;interface graphique de Woodstock √† chaque fois.\nEn 2018, le BFEC a commenc√© √† s\u0026rsquo;int√©resser √† un outil permettant de quantifier les stocks de carbone dans les for√™ts. L\u0026rsquo;outil choisi (GCBM) fait des estimations pr√©cises des stocks et des flux de carbone, mais il a besoin d\u0026rsquo;informations sur l\u0026rsquo;endroit et le moment des coupes dans le paysage forestier, selon diff√©rents sc√©narios d\u0026rsquo;am√©nagement forestier.\nPour cette raison, un mod√®le √©tait n√©cessaire pour transformer les informations r√©f√©renc√©es spatialement des mod√®les de Woodstock (qui regroupent toutes les for√™ts du m√™me type dans le paysage) en informations spatialement explicites (qui se trouvent √† un emplacement pr√©cis sur une carte).\nDe 2019 √† aujourd\u0026rsquo;hui, de nombreuses fonctionnalit√©s ont √©t√© impl√©ment√©es pour am√©liorer les performances de FMT, et sa capacit√© √† faire de la replanification.\nQuels est le futur de FMT ? Une interface utilisateur.ice pour certaines fonctions utiles aux analystes du BFEC, et pour son int√©gration avec GCBM Optimisation spatialement explicite (actuellement, l\u0026rsquo;optimisation se fait au niveau spatialement r√©f√©renc√©, et les r√©sultats sont ensuite rendus spatialement explicites avec des heuristiques) De meilleures sorties (outputs) pour faciliter son int√©gration avec d\u0026rsquo;autres mod√®les ou scripts Maintenant que vous en savez tant sur FMT, vous n\u0026rsquo;aurez aucun mal √† comprendre comment il fonctionne et comment l\u0026rsquo;utiliser.\nSi vous ne connaissez rien aux mod√®les Woodstock, vous devriez prendre le temps de lire √† leur propos avant de lire cette documentation. Vous vous sentirez un peu perdu si vous ne le faites pas. Pr√™t.e √† commencer ?\nüìñ Commencer √† lire ","date":1536451200,"expirydate":-62135596800,"kind":"section","lang":"fr","lastmod":1536451200,"objectID":"04db5c02e6f257acc19ec89db5919756","permalink":"https://bureau-du-forestier-en-chef.github.io/FMTdocs/fr/docs/basics/","publishdate":"2018-09-09T00:00:00Z","relpermalink":"/FMTdocs/fr/docs/basics/","section":"docs","summary":"Comprendre ce que FMT est, et ce qu'il fait.","tags":null,"title":"Les bases de FMT","type":"book"},{"authors":null,"categories":null,"content":"FMT est un programme qui n√©cessite d\u0026rsquo;√™tre compil√© sur votre ordinateur pour pouvoir √™tre ex√©cut√©.\nNe vous inqui√©tez pas ; ce n\u0026rsquo;est pas aussi complexe qu\u0026rsquo;il n\u0026rsquo;y para√Æt !\nQu\u0026rsquo;est-ce que la compilation ? La compilation est une √©tape au cours de laquelle votre ordinateur va transformer le code source (qui sont des fichiers que vous, en tant qu\u0026rsquo;humain.e, pouvez lire) du programme en un ensemble de binaires (binaries) (qui sont des fichiers que votre ordinateur peut lire).\nVous utilisez des binaries tous les jours, sans m√™me y penser. Par exemple, un fichier .exe sous Windows est un binarie. Si vous l\u0026rsquo;ouvrez avec le bloc-notes de Windows, vous ne serez pas en mesure de comprendre son contenu, mais votre ordinateur le peut. Que faut-il pour compiler ? Pour compiler FMT, votre ordinateur aura besoin :\nDu code source de FMT De toutes les biblioth√®ques de fonctions utilis√©es par FMT D\u0026rsquo;un compilateur La documentation vous guidera pour toutes ces √©tapes.\nTout pr√©parer prend environ une demi-heure, mais le t√©l√©chargement et la compilation prennent environ 6 heures (mais vous n\u0026rsquo;avez rien √† faire pendant que votre ordinateur s\u0026rsquo;en occupe). Actuellement, cette documentation pour la compilation de FMT ne couvre que l\u0026rsquo;installation de FMT pour Windows 8-10, et pour une utilisation sous Python.\nSi vous √™tes un utilisateur de Mac ou de Linux, ou si vous voulez utiliser FMT sous R, veuillez nous pr√©venir dans la section issue section of the FMT repository.\nPr√™t.e √† commencer ?\nüíæ Commencer l\u0026rsquo;installation ","date":1536451200,"expirydate":-62135596800,"kind":"section","lang":"fr","lastmod":1536451200,"objectID":"cb3f7061761e7263b0c7801f991613a2","permalink":"https://bureau-du-forestier-en-chef.github.io/FMTdocs/fr/docs/download_install/","publishdate":"2018-09-09T00:00:00Z","relpermalink":"/FMTdocs/fr/docs/download_install/","section":"docs","summary":"D√©couvrez comment t√©l√©charger et installer FMT sur votre ordinateur.","tags":null,"title":"T√©l√©chargement et installation","type":"book"},{"authors":null,"categories":null,"content":"FMT poss√®de des fonctions avanc√©es telle que la replanification, qui permettent d\u0026rsquo;explorer des questions complexes li√©es √† l\u0026rsquo;am√©nagement forestier et √† son optimisation.\nCette section de la documentation va toucher √† ses fonctions avanc√©es une par une.\nSi vous ne les avez pas encore lues, nous vous recommandons de commencer par les sections bases de FMT et t√©l√©chargement et installation avant de commencer √† lire celle-ci.\nVous serez normalement en mesure de comprendre cette section qu\u0026rsquo;une fois que vous connaissez les bases de FMT.\nPr√™t.e √† commencer ?\nüìñ Commencer √† lire ","date":1536451200,"expirydate":-62135596800,"kind":"section","lang":"fr","lastmod":1536451200,"objectID":"855747809fc2a2d136fdd237db304949","permalink":"https://bureau-du-forestier-en-chef.github.io/FMTdocs/fr/docs/advanced/","publishdate":"2018-09-09T00:00:00Z","relpermalink":"/FMTdocs/fr/docs/advanced/","section":"docs","summary":"D√©couvrir les fonctions les plus pouss√©es de FMT, comme la replanification.","tags":null,"title":"Les fonctions avanc√©es","type":"book"},{"authors":null,"categories":null,"content":" Les pr√©sentations seront d√©form√©es si vous les regardez sur mobiles. Il est recommand√© de les visionner sur une tablette ou un ordinateur de bureau ! Pr√©sentation sur le carbone avec machine learning Pr√©sentation sur l\u0026rsquo;avancement de FMT (28/04/22) Pr√©sentation sur le Presolve de FMT Pr√©sentation sur la mise √† jour de mod√®le Pr√©sentation sur l\u0026rsquo;avancement IA carbone Pr√©sentation rencontre_250723 ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"fr","lastmod":-62135596800,"objectID":"7b6ed69e4c59bce356b308ed15e667e8","permalink":"https://bureau-du-forestier-en-chef.github.io/FMTdocs/fr/docs/slides_links/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/FMTdocs/fr/docs/slides_links/","section":"docs","summary":"Acc√©dez aux pr√©sentations sur FMT","tags":null,"title":"Pr√©sentations","type":"book"},{"authors":null,"categories":null,"content":"Bienvenue dans la documentation de FMT !\nAvant de commencer √† lire, sachez que vous pouvez modifier l\u0026rsquo;apparence de la documentation (th√®me clair ou sombre) en utilisant la petite ic√¥ne de lune ou de soleil dans le coin sup√©rieur droit de l\u0026rsquo;√©cran. Si vous ne connaissez rien aux mod√®les Woodstock, vous devriez prendre le temps de lire √† leur propos avant de lire cette documentation. Vous vous sentirez un peu perdu si vous ne le faites pas. Si vous voulez mieux comprendre ce qu\u0026rsquo;est FMT et ce qu\u0026rsquo;il fait, vous pouvez commencer par les bases :\n‚ú® D√©couvrir les bases de FMT Si vous souhaitez installer FMT, consultez les instructions d\u0026rsquo;installation :\nüíæ T√©l√©charger et installer FMT Sinon, vous pouvez utiliser la barre de recherche ou la table des mati√®res √† votre gauche pour trouver ce que vous cherchez.\nBonne lecture !\n","date":1557010800,"expirydate":-62135596800,"kind":"section","lang":"fr","lastmod":1557010800,"objectID":"4cdd37113783e47641dd300543c94e1b","permalink":"https://bureau-du-forestier-en-chef.github.io/FMTdocs/fr/docs/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/FMTdocs/fr/docs/","section":"docs","summary":"Bienvenue dans la documentation de FMT !\nAvant de commencer √† lire, sachez que vous pouvez modifier l\u0026rsquo;apparence de la documentation (th√®me clair ou sombre) en utilisant la petite ic√¥ne de lune ou de soleil dans le coin sup√©rieur droit de l\u0026rsquo;√©cran.","tags":null,"title":"Documentation de FMT","type":"book"},{"authors":null,"categories":null,"content":"Qu\u0026rsquo;est-ce que la replanification ? La replanification est un processus qui consiste √† resolutioner un mod√®le d\u0026rsquo;optimisation de coupes foresti√®res (comme ceux utilis√©s dans FMT) pour prendre en compte des √©l√©ments qui ne peuvent pas √™tre consid√©r√©s dans le processus classique de r√©solution de ces mod√®les d\u0026rsquo;optimisation.\nLa replanification permet donc de se poser des questions plus complexes; en particulier, elle permet de toucher aux interactions entre les diff√©rents niveaux de la planification hi√©rarchique en foresterie (strat√©gique, tactique et op√©rationnel).\nVoici quelques exemples de questions auxquelles la replanification permet de r√©pondre :\nDes questions li√©es aux effets des perturbations naturelles (feux, tordeuse des bourgeons de l\u0026rsquo;√©pinette, etc.) Quel est l\u0026rsquo;effet des feux √† long terme sur les niveaux de r√©colte d√©termin√©s par le niveau strat√©gique ? Quel est l\u0026rsquo;effet d\u0026rsquo;un changement de r√©gime d\u0026rsquo;une perturbation stochastique (al√©atoire) sur les niveaux de r√©colte d√©termin√©s par le niveau strat√©gique ? Des questions li√©s aux incoh√©rences entre ce qui est pr√©vu au niveau strat√©gique (√† grande √©chelle), et la r√©alit√© du terrain (√† petite √©chelle) : c\u0026rsquo;est la notion de drift entre les diff√©rents niveaux de l\u0026rsquo;am√©nagement hi√©rarchique Est-ce que les objectifs sont toujours atteints en prenant en compte des probl√©matiques et des contraintes plus pr√©cises au niveau tactique ? Des questions li√©es aux interactions entre les niveaux strat√©gique et tactique Quel est l\u0026rsquo;effet de communiquer (ou non) certaines informations au mod√®le tactique ou strat√©gique ? Qu\u0026rsquo;est-ce qui change ? Qu\u0026rsquo;est-ce qui ne change pas ? La replanification spatialement r√©f√©renc√©e en pratique Les mod√®les utilis√©s Lorsqu\u0026rsquo;on utilise FMT, la replanification spatialement r√©f√©renc√©e se fait en pratique √† l\u0026rsquo;aide de trois mod√®les de FMT.\nCes trois mod√®les repr√©sentent trois sc√©narios appliqu√©s √† un m√™me paysage initial(m√™mes sections AREA, CONSTANTS, LANDSCAPE, OUTPUTS). Cependant, ces sc√©narios peuvent avoir des √©l√©ments diff√©rents les uns des autres (sections ACTIONS, TRANSITIONS, YIELDS et OPTIMIZE diff√©rentes).\nCes trois mod√®les sont :\n1. Le mod√®le strat√©gique\nC\u0026rsquo;est un mod√®le de programmation lin√©aire de type III, comme d√©crit dans les bases de FMT.\nC\u0026rsquo;est ce mod√®le qui va repr√©senter ce qui se passe au niveau strat√©gique, c\u0026rsquo;est-√†-dire quand on regarde les choses d\u0026rsquo;en haut sans prendre en compte certains d√©tails √† des √©chelles plus fines.\n2. Le mod√®le stochastique\nC\u0026rsquo;est un mod√®le de simulation non-spatial (qui fonctionne dans un espace spatialement r√©f√©renc√© comme les mod√®les lin√©aires, et non pas spatialement explicite).\nIl va servir √† simuler des actions pseudo-al√©atoires avec des cibles de superficies √† atteindre. Ces actions peuvent repr√©senter des feux de for√™ts, des √©pid√©mies d\u0026rsquo;insectes, et bien d\u0026rsquo;autres encore !\nUne simulation pseudo-al√©atoire signifie que les composantes al√©atoires de la simulation se basent sur un chiffre d√©termin√© que l\u0026rsquo;on appelle la \u0026ldquo;graine\u0026rdquo; (seed). Deux simulations pseudo-al√©atoires faites avec la m√™me graine auront exactement les m√™mes r√©sultats; mais changer la graine donne des r√©sultats diff√©rents et al√©atoires. C\u0026rsquo;est un fonctionnement tr√®s pratique pour avoir de l\u0026rsquo;al√©atoire, tout en gardant une certaine stabilit√© dans les r√©sultats obtenus. 3. Le mod√®le tactique\nComme le mod√®le strat√©gique, c\u0026rsquo;est un mod√®le de programmation lin√©aire de type III, comme d√©crit dans les bases de FMT.\nCe mod√®le va servir √† refaire une optimisation de la planification foresti√®re tout en prenant en compte les changements que le mod√®le stochastique √† pu effectuer sur le paysage, ou bien avec des contraintes diff√©rentes ou suppl√©mentaires par rapport au mod√®le strat√©gique.\nL\u0026rsquo;exemple d\u0026rsquo;une it√©ration de replanification La replanification se fait √† l\u0026rsquo;aide des trois mod√®les d√©crits pr√©c√©demment, en les appelant les un apr√®s les autres au sein de chaque p√©riode de replanification. Comme l\u0026rsquo;un des mod√®les (le mod√®le stochastique) contient des √©v√©nements al√©atoires, il est cependant possible de refaire tout le processus plusieurs fois afin de prendre en compte la variabilit√© li√©e √† ces √©v√©nements al√©atoires : c\u0026rsquo;est ce que l\u0026rsquo;on appelle une it√©ration.\nLorsqu\u0026rsquo;on appelle les mod√®les les un apr√®s les autres, certaines de leur caract√©ristiques sont pass√©es de l\u0026rsquo;un √† l\u0026rsquo;autre (inventaire/√©tat du paysage pour la p√©riode, ou bien contraintes et planification existante).\nAu final, une it√©ration de replanification prend la forme suivante :\nDans ce sch√©ma,\nSTRA correspond au mod√®le strat√©gique STO correspond au mod√®le stochastique TAC correspond au mod√®le tactique On peut ainsi voir que pour chaque p√©riode,\nLe mod√®le strat√©gique est appel√© pour faire sa planification La planification du mod√®le strat√©gique se fait sur un horizon long; et cet horizon ne change pas √† travers les p√©riodes. C\u0026rsquo;est-√†-dire qu\u0026rsquo;√† chaque p√©riode, le mod√®le strat√©gique va, par exemple, planifier pour les 100 ans √† venir; que ce soit 100 ans apr√®s la p√©riode 1, ou 100 ans apr√®s la p√©riode 3. Le mod√®le strat√©gique partage le m√™me inventaire que le mod√®le stochastique, ce dernier est appel√© √† faire sa simulation pour introduire des diff√©rences avec l\u0026rsquo;inventaire qui sera pass√©e au mod√®le tactique. Le mod√®le stochastique ne va faire cette simulation que pour la p√©riode de temps donn√©e (contrairement au mod√®le de planification qui va faire son optimisation en prenant en compte le long terme). C\u0026rsquo;est parce que le mod√®le stochastique ne fait que simuler des √©v√©nements al√©atoires, et ne cherche pas √† optimiser quoi que ce soit. L\u0026rsquo;inventaire r√©sultant du mod√®le stochastique va √™tre pass√© au mod√®le tactique, qui est appel√© pour faire sa replanification Le mod√®le tactique ne va planifier que sur la p√©riode donn√©e; il ne va pas simuler le long-terme comme le mod√®le strat√©gique, m√™me s\u0026rsquo;il essaye de faire une optimisation. Son objectif sera, par exemple, de r√©colter du bois sans d√©passer la quantit√© de bois r√©colt√©e par le mod√®le strat√©gique, mais en prenant en compte l\u0026rsquo;inventaire modifi√© par les √©v√©nements al√©atoires du mod√®le stochastique. L\u0026rsquo;inventaire r√©sultant du mod√®le tactique est ensuite repass√© au mod√®le strat√©gique, qui va ensuite planifier √† nouveau pour la p√©riode suivante. On peut ainsi voir deux vas-et-viens entre les mod√®les :\nLe passage de l\u0026rsquo;inventaire d\u0026rsquo;un mod√®le √† un autre au fur et √† mesure du processus (lignes bleues sur le sch√©ma) Le passage de contraintes de planification du mod√®le strat√©gique au mod√®le tactique (lignes jaunes sur le sch√©ma) Notez bien que tout ce processus ne repr√©sente qu\u0026rsquo;une seule it√©ration de la replanification. Afin de r√©ellement prendre en compte les effets des √©venements stochastiques, il est important de r√©p√©ter tout ce processus de nombreuses fois. Cela permet de prendre en compte la variabilit√© qui existera dans la mani√®re dont l\u0026rsquo;inventaire et le mod√®le tactique vont r√©agir aux √©v√©nements al√©atoires; le mod√®le tactique peut aussi contenir des composantes al√©atoires en son sein.\nLes mod√®les de replanification en d√©tail Le mod√®le strat√©gique C\u0026rsquo;est un mod√®le d‚Äôoptimisation par programmation lin√©aire (FMTlpmodel). Il ne prend pas en compte les perturbations naturelles ou les √©v√©nements stochastiques. Normalement, il a un horizon de planification long pour faire le suivi de variables et optimiser certains √©l√©ments sur le long terme (e.g. 100 √† 150 ans). Il dicte la voie √† prendre au mod√®le tactique en lui transmettant des informations. Il peut utiliser le nouveau mot cl√© _SETFROMLOCAL(ratio). Le mod√®le stochastique C\u0026rsquo;est un mod√®le de simulation non-spatial (FMTnssmodel). Il simule des perturbations naturelles ou des √©v√©nements stochastiques. Il peut poss√©der un horizon de simulation long; mais il ne simule qu\u0026rsquo;une p√©riode √† la fois. Son r√¥le est d\u0026rsquo;affecter le territoire utilis√© par le mod√®le tactique, et donc de brouiller les cartes entre le mod√®le strat√©gique et le mod√®le tactique. Il peut utiliser les nouveaux mots cl√©s _RANDOM(output) et _REPLICATE(output). Le mod√®le stochastique n\u0026rsquo;est pas n√©cessaire ou obligatoire pour faire de la replanification. Certaines questions qui peuvent √™tre adress√©es par la replanification n\u0026rsquo;ont pas de lien avec des perturbations al√©atoires. Par exemple, on peut s\u0026rsquo;int√©resser aux d√©calages entre un mod√®le strat√©gique qui ne prend pas en compte des contraintes √† plus petites √©chelles (e.g. terrain, fluctuations √©conomiques, etc.), et un mod√®le tactique qui les prend en compte. Dans ce cas-ci, de la stochasticit√© peut exister dans les solutions du mod√®les tactique, mais elle ne requi√®re pas l\u0026rsquo;utilisation d\u0026rsquo;un mod√®le stochastique pour alt√©rer l\u0026rsquo;inventaire o√π le paysage forestier entre le mod√®le stochastique et tactique. Le mod√®le tactique C\u0026rsquo;est un mod√®le d‚Äôoptimisation par programmation lin√©aire (FMTlpmodel), comme le mod√®le strat√©gique. Son horizon de planification est de seulement une p√©riode. Car √† l\u0026rsquo;√©chelle tactique, on ne prend en compte que le court-terme, et non le long-terme. Son √©tat initial est celui de la p√©riode actuelle, donn√© par le mod√®le stochastique. Il peut utiliser les nouveaux mots cl√©s _SETFROMGLOBAL(ratio) et _SETGLOBALSCHEDULE(ratio). Les nouveaux mots-cl√©s associ√©s √† la replanification Diff√©rents mots cl√©s qui n\u0026rsquo;existent pas dans la syntaxe Woodstock permettent d\u0026rsquo;impl√©menter des va-et-vient d\u0026rsquo;information entre les diff√©rents mod√®les de la replanification, selon le sch√©ma suivant :\nD\u0026rsquo;autres permettent d\u0026rsquo;ignorer des contraintes √† des moments donn√©s, ou bien de les ajuster.\nVous trouverez ici la liste de ces nouveaux mots-cl√©s li√©s √† la replanification :\n_REIGNORE(period) Ce mot cl√© doit appara√Ætre dans la section OPTIMIZE d\u0026rsquo;un mod√®le.\nIl permet d\u0026rsquo;indiquer au mod√®le d\u0026rsquo;ignorer une contrainte √† partir d\u0026rsquo;une p√©riode de replanification pr√©cise.\nCeci peut √™tre tr√®s utile pour instaurer une p√©riode de mise √† jour de la planification, et ensuite ignorer les contraintes qui y sont li√©es.\nIl ne faut pas oublier que le mod√®le strat√©gique est r√©p√©t√© √† toutes les p√©riodes de replanification, sur tout son horizon de planification. Si son horizon est de 100 ans et que les p√©riodes de planification sont de 10 ans, il sera alors appel√© √† la p√©riode 3 √† planifier √† partir de l‚Äôinventaire qui a √©t√© modifi√© par les 2 p√©riodes de replanification pr√©c√©dentes. Donc, il commencera 30 ans apr√®s le d√©but de la p√©riode initiale de replanification et son horizon se terminera 130 ans apr√®s le d√©but de la p√©riode initiale de replanification. _REPLICATE(fichier.csv) Ce mot cl√© permet de venir changer le terme √† droite de l\u0026rsquo;√©quation (Right Hand Side, ou RHS) d\u0026rsquo;une contrainte en venant chercher une valeur dans un tableau contenant ces valeurs pour diff√©rents r√©plicas.\nEn pratique, on peu d√©poser un fichier .csv dans le r√©pertoire du sc√©nario, puis utiliser _REPLICATE(fichier.csv) pour que FMT applique une certaine valeur dans ce tableau pour l\u0026rsquo;it√©ration √† laquelle il se trouve.\nPar exemple, √©crire la chose suivante dans la section des contraintes d\u0026rsquo;un mod√®le :\n_RANDOM(outputaction) \u0026lt;= 10 1 _REPLICATE(fichier.csv)\rpermet de remplacer, √† chaque it√©ration, le chiffre \u0026ldquo;10\u0026rdquo; de la contrainte par le chiffre de la ligne 1 du fichier fichier.csv avec la colonne qui correspond √† l\u0026rsquo;it√©ration.\nDans le fichier, les lignes correspondent donc √† la p√©riode et les colonnes √† l\u0026rsquo;it√©ration √† laquelle on veut que la valeur s\u0026rsquo;applique.\n_SETFROMLOCAL(ratio) Ce mot cl√© permet au mod√®le strat√©gique d\u0026rsquo;ajuster une de ses contraintes en fonction de la valeur du output correspondant dans le mod√®le tactique utilis√© √† la p√©riode pr√©c√©dente.\nAvec cette contrainte, on pr√©cise un ratio qui peut augmenter ou diminuer la valeur prise du mod√®le tactique. Par exemple, un ratio de 1.0 donnera exactement la valeur du mod√®le tactique; un ratio de 2.0 va la multiplier par deux, et un ratio de 0.5 la divisera par deux.\nSi on √©crit la chose suivante dans la section des contraintes d\u0026rsquo;un mod√®le strat√©gique :\nVOLUMEREC \u0026lt;= 0 1.._LENGTH _SETFROMLOCAL(1)\ron se trouve √† remplacer syst√©matiquement le chiffre \u0026ldquo;0\u0026rdquo; du RHS par la valeur du output VOLUMEREC de la p√©riode de replanification pr√©c√©dente du mod√®le tactique.\n_RANDOM(output) Ce mot cl√© est utilis√© pour g√©n√©rer des valeurs de fa√ßon al√©atoire pour le mod√®le stochastique.\nL\u0026rsquo;output choisi avec _RANDOM(output) doit √™tre un output d\u0026rsquo;action, et non un output d\u0026rsquo;inventaire. Il s\u0026rsquo;√©crit comme pour une contrainte standard.\nVoici un exemple pour g√©n√©rer un chiffre al√©atoire entre 50 et 100 pour les p√©riodes 1 √† LENGTH :\n_RANDOM(outputaction) \u0026lt;= 50 1.._LENGTH\r_RANDOM(outputaction) \u0026gt;= 100 1.._LENGTH\r_SETFROMGLOBAL(ratio) Ce mot-cl√© est utilis√© pour ajuster une contrainte du mod√®le tactique bas√© sur une valeur d√©termin√©e par le mod√®le strat√©gique. C\u0026rsquo;est un peu la r√©ciproque de _SETFROMLOCAL(ratio).\nLe ratio permet d\u0026rsquo;augmenter ou de diminuer la valeur prise du mod√®le strat√©gique. Par exemple, un ratio de 1.0 donnera exactement la valeur du mod√®le strat√©gique; un ratio de 2.0 va la multiplier par deux, et un ratio de 0.5 la divisera par deux.\nSi on √©crit la chose suivante dans la section des contraintes d\u0026rsquo;un mod√®le tactique :\nVOLUMEREC \u0026lt;= 0 1.._LENGTH _SETFROMGLOBAL(1)\ron remplace syst√©matiquement le chiffre \u0026ldquo;0\u0026rdquo; du RHS par la valeur du output VOLUMEREC du mod√®le strat√©gique pour la p√©riode de replanification en cours.\n_SETGLOBALSCHEDULE(ratio) Ce mot cl√© permet d\u0026rsquo;inclure la solution (ce qui a √©t√© planifi√© comme actions) du mod√®le strat√©gique dans le mod√®le tactique sous forme de poids √† la fonction objective.\nPour ce faire, lors de l\u0026rsquo;√©valuation de la solution du mod√®le tactique, √† chaque fois que ce dernier planifiera une action sur un m√™me d√©veloppement que pr√©vu au mod√®le strat√©gique, il multipliera la superficie planifi√©e (au niveau tactique) par le ratio sp√©cifi√© et ajoutera la valeur √† l\u0026rsquo;objectif selon la formulation de la fonction objective. Si le mod√®le doit maximiser, on additionnera et s\u0026rsquo;il doit minimiser, on soustraiera la valeur calcul√©e.\nLes r√©sultats de la replanification Suite au processus de replanification, on obtient les r√©sultats suivants :\nTrois fichiers de r√©sultats bruts (un par mod√®le) Un fichier de probabilit√©s (un seul pour tout le processus) Les fichiers de r√©sultats bruts par mod√®les Ces fichiers contiennent des valeurs li√©es aux outputs dans les diff√©rents mod√®les, pour les diff√©rentes p√©riodes, et pour les diff√©rentes it√©rations.\nIls contiennent diff√©rentes colonnes :\nIteration : Indique le num√©ro de l\u0026rsquo;it√©ration qui est fait pour prendre en compte de la stochasticit√©. L\u0026rsquo;it√©ration \u0026ldquo;0\u0026rdquo; concerne le mod√®le strat√©gique \u0026ldquo;de base\u0026rdquo;, qui est r√©solu au tout d√©but du processus de replanification. Period : Indique la p√©riode de replanification qui concerne la valeur de l\u0026rsquo;output. Output : Nom de l\u0026rsquo;output consid√©r√©. Value : Valeur du output consid√©r√©. Type : Type de output (indique si c\u0026rsquo;est un output \u0026ldquo;total\u0026rdquo; pour tout le paysage, ou par d√©veloppement/peuplement). Le fichier de probabilit√©s Ce fichier contient les probabilit√©s que des outputs du mod√®le tactique puissent s\u0026rsquo;√©loigner (drift) de la solution du mod√®le strat√©gique initial (r√©solu au tout d√©but du processus de replanification), dont les outputs se trouvent dans l\u0026rsquo;it√©ration \u0026ldquo;0\u0026rdquo; des fichiers de r√©sultats bruts.\nPour chacun des outputs d√©finis dans les mod√®les, le fichier de probabilit√© contiendra toutes les probabilit√©s de rester dans l\u0026rsquo;intervalle inf√©rieur et sup√©rieur du ratio d\u0026rsquo;√©loignement (drift) vis-√†-vis des outputs du mod√®le strat√©gique initial, pour les valeurs de ratio d\u0026rsquo;√©loignement suivantes : 0, 0.05, 0.10, 0.15, 0.20, 0.25, 0.30, 0.35, 0.40, 0.45, 0.50.\nCe fichier contient diff√©rentes colonnes :\nPeriod : Indique la p√©riode de replanification qui concerne la valeur de l\u0026rsquo;output. Output : Nom de l\u0026rsquo;output consid√©r√©. LowerProbability : Probabilit√© de rester dans l\u0026rsquo;intervalle inf√©rieure du ratio d\u0026rsquo;√©loignement. UpperProbability : Probabilit√© de rester dans l\u0026rsquo;intervalle sup√©rieure du ratio d\u0026rsquo;√©loignement. Drift : Ratio d\u0026rsquo;√©loignement entre la solution du mod√®le tactique et celle du mod√®le strat√©gique initial. Plus vous ferez d\u0026rsquo;it√©rations lors de votre replanification, et plus vos probabilit√©s seront repr√©sentatives et stables dans le temps. √Ä l\u0026rsquo;inverse, un petit nombre d\u0026rsquo;it√©rations tendra √† r√©sulter ou des estimations tr√®s changeantes, et souvent incompl√®tes. Pour comprendre les probabilit√©s, il faut d\u0026rsquo;abord regarder le ratio d\u0026rsquo;√©loignement, la valeur du mod√®le strat√©gique initial, puis les probabilit√©s.\nPar exemple :\nSi la valeur du mod√®le strat√©gique initial pour un output donn√© est de 1000. Et si, pour la p√©riode 1, on obtient une LowerProbability de 1 et une UpperProbability de 1 pour un drift de 0.3. Alors, cela veut dire qu\u0026rsquo;il y a une probabilit√© de 100% pour que l\u0026rsquo;output reste entre une valeur de 700 et de 1300 pour la p√©riode 1. Et si, pour la p√©riode 10, on obtient une LowerProbability de 0.6 et une UpperProbability de 0.4 pour un drift de 0.5. Alors, cela veut dire qu\u0026rsquo;il y a une probabilit√© de 60% que l\u0026rsquo;output reste au dessus de 500, et une probabilit√© de 40% qu\u0026rsquo;il reste en dessous de 1500 √† la p√©riode 10. Le fichier de probabilit√© permet, par exemple, de v√©rifier qu\u0026rsquo;un certain sc√©nario a de meilleures probabilit√©s de se maintenir entre certaines valeurs qu\u0026rsquo;un autre sc√©nario. Les fichiers de r√©sultats bruts des 3 mod√®les peuvent cependant √™tre utilis√©s pour faire des analyses plus complexes, ou bien pour valider des hypoth√®ses en ce qui concerne la communication entre les trois mod√®les. ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"fr","lastmod":1557010800,"objectID":"0fd33677d422ed7ada68ec4301dbfaa2","permalink":"https://bureau-du-forestier-en-chef.github.io/FMTdocs/fr/docs/advanced/replanning/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/FMTdocs/fr/docs/advanced/replanning/","section":"docs","summary":"Qu\u0026rsquo;est-ce que la replanification ? La replanification est un processus qui consiste √† resolutioner un mod√®le d\u0026rsquo;optimisation de coupes foresti√®res (comme ceux utilis√©s dans FMT) pour prendre en compte des √©l√©ments qui ne peuvent pas √™tre consid√©r√©s dans le processus classique de r√©solution de ces mod√®les d\u0026rsquo;optimisation.","tags":null,"title":"Replanification spatialement r√©f√©renc√©e","type":"book"},{"authors":null,"categories":null,"content":"Dans cet exercice, vous allez essayer d\u0026rsquo;utiliser FMT pour r√©pondre √† diff√©rentes questions concernant un mod√®le strat√©gique et un mod√®le tactique, par le biais d\u0026rsquo;un processus de replanification.\nAinsi, cet exercice vous apprendra √† :\nR√©aliser un script de replanification Faire une replanification avec plusieurs mod√®les, en variant les mots cl√©s sp√©ciaux de FMT Analyser les r√©sultats des replanifications pour r√©pondre √† diff√©rentes questions Pour faire cet exercice, vous devez avoir install√© FMT sur votre ordinateur et avoir t√©l√©charg√© les fichiers d\u0026rsquo;exemple depuis le d√©p√¥t GitHub de FMT.\nüíæ T√©l√©charger et installer FMT üíæ T√©l√©charger les fichiers d\u0026rsquo;exemples de FMT Vous devez √©galement avoir install√© Python sur votre ordinateur. Si cela n\u0026rsquo;est pas fait, r√©f√©rez-vous √† cette page.\n1√®re partie : Cr√©ation d\u0026rsquo;un script de replanification Si vous ne connaissez pas beaucoup le langage Python, ou bien si vous n\u0026rsquo;avez vraiment pas le temps, vous pouvez sauter cette section et utiliser le script Replanner.py qui se trouve dans le dossier \u0026ldquo;Examples\u0026rdquo; que vous avez t√©l√©charg√©, dans le dossier /Python/replanning. Le processus de replanification implique souvent de lancer de nombreux mod√®les, et de nombreuses fois (pour faire des it√©rations).\nIl est ainsi tr√®s utile de creer un script Python qui peut √™tre appell√© par le biais d\u0026rsquo;une console, d\u0026rsquo;un terminal, ou d\u0026rsquo;une invite de commande.\nEncore mieux : il est possible de cr√©er un script Python qui lira des arguments qui lui seront fournis lorsqu\u0026rsquo;il sera appel√© avec l\u0026rsquo;invite de commande. Cela permettra de r√©utiliser ce script pour diff√©rentes replanifications.\nEssayez alors de cr√©er en langage Python le script suivant :\nImportation de Models, Parser, Core, Version et Parallel depuis FMT Lecture des arguments suivants (il est recommand√© d\u0026rsquo;utiliser le module argparse) -pri qui indique la localisation du fichier primaire des mod√®les qui seront utilis√©s -str qui indique le nom du sc√©nario strat√©gique -tac qui indique le nom du sc√©nario tactique -sto qui indique le nom du sc√©nario stochastique -out qui indique une liste d\u0026rsquo;outputs d\u0026rsquo;int√©ret, s√©par√©s par une virgule, √† extraire des r√©sultats des mod√®les -fol qui indique le dossier o√π les sorties du script seront mises -rep qui indique le nombre d\u0026rsquo;it√©rations √† faire -len qui indique le nombre de p√©riodes du mod√®le strat√©gique -rel qui indique le nombre de p√©riodes sur lesquelles la replanification va se faire -thr qui indique le nombre de coeurs de CPU √† utiliser pour faire des it√©rations en parral√®le Ensuite, le script devra :\nLire le mod√®le via le fichier primaire Lire les diff√©rents sc√©narios Cr√©er le mod√®le strat√©gique/global en utilisant le nom de sc√©nario fournis par -str Faire en sorte que le mod√®le global se fasse sur la dur√©e fournie par -len Faire en sorte que le mod√®le global utilise le nombre de threads indiqu√©s par -thr pour la r√©solution en parall√®le Cr√©er le mod√®le stochastique en utilisant le nom de sc√©nario fournis par -sto Faire en sorte que le mod√®le stochastique se fasse sur la dur√©e de une p√©riode Cr√©er le mod√®le tactique en utilisant le nom de sc√©nario fournis par -tac Faire en sorte que le mod√®le tactique se fasse sur la dur√©e de une p√©riode Faire en sorte que le mod√®le global utilise le nombre de threads indiqu√©s par -thr pour la r√©solution en parall√®le Ajouter les outputs selectionn√©s par l\u0026rsquo;argument -out dans une liste depuis les outputs des mod√®les Pr√©parer la t√¢che de replanning par le biais de la fonction Parallel.FMTreplanningtask() en fournissant √† la fonction : Le mod√®le strat√©gique Le mod√®le stochastique Le mod√®le tactique La liste des outputs voulus Le dossier o√π les outputs seront mis Le format des outputs (ici, .csv) Tous les autres arguments n√©c√©ssaires √† la fonction Lancer la t√¢che de replanning par le biais de la fonction Parallel.FMTtaskhandler() Lorsque vous avez termin√©, ou si vous √™tes bloqu√©.e, vous pouvez afficher la correction de cet exercice pour du code Python en cliquant sur le bouton \u0026ldquo;R√©v√©ler la correction\u0026rdquo; ci-dessous.\nR√©v√©ler la correction from FMT import Models\rfrom FMT import Parser\rfrom FMT import Core\rfrom FMT import Version\rfrom FMT import Parallel\rimport os,argparse\rif __name__ == \u0026quot;__main__\u0026quot;:\rap = argparse.ArgumentParser()\rap.add_argument(\u0026quot;-pri\u0026quot;, \u0026quot;--primary\u0026quot;, required=True,help=\u0026quot;Fichier primaire\u0026quot;)\rap.add_argument(\u0026quot;-str\u0026quot;, \u0026quot;--strategic\u0026quot;, required=True,help=\u0026quot;Nom du scenario strategique\u0026quot;)\rap.add_argument(\u0026quot;-tac\u0026quot;, \u0026quot;--tactic\u0026quot;, required=True,help=\u0026quot;Nom du scenario tactique\u0026quot;)\rap.add_argument(\u0026quot;-sto\u0026quot;, \u0026quot;--stochastic\u0026quot;, required=True,help=\u0026quot;Nom du scenario stochastique\u0026quot;)\rap.add_argument(\u0026quot;-out\u0026quot;, \u0026quot;--outputs\u0026quot;, required=True,help=\u0026quot;Liste d'outputs separe d'une virgule\u0026quot;)\rap.add_argument(\u0026quot;-fol\u0026quot;, \u0026quot;--folder\u0026quot;, required=True,help=\u0026quot;Dossier de sortie\u0026quot;)\rap.add_argument(\u0026quot;-rep\u0026quot;, \u0026quot;--replicates\u0026quot;, required=True,help=\u0026quot;Nombre de replicas\u0026quot;)\rap.add_argument(\u0026quot;-len\u0026quot;, \u0026quot;--strategiclength\u0026quot;, required=True,help=\u0026quot;Nombre de periode du strategique\u0026quot;)\rap.add_argument(\u0026quot;-rel\u0026quot;, \u0026quot;--replanninglength\u0026quot;, required=True,help=\u0026quot;Nombre de periode de re-plannification\u0026quot;)\rap.add_argument(\u0026quot;-thr\u0026quot;, \u0026quot;--threads\u0026quot;, required=True,help=\u0026quot;Nombre de threads\u0026quot;)\rap.add_argument(\u0026quot;-com\u0026quot;,\u0026quot;--compresstime\u0026quot;, nargs=\u0026quot;+\u0026quot;,help=\u0026quot;Compress time sous la forme 20,5 40,8\u0026quot;)\rargs = vars(ap.parse_args())\rif Version.FMTversion().hasfeature(\u0026quot;OSI\u0026quot;):\rmodelparser = Parser.FMTmodelparser()\rpath = args[\u0026quot;primary\u0026quot;]\rscenarios = [args[\u0026quot;strategic\u0026quot;],args[\u0026quot;stochastic\u0026quot;],args[\u0026quot;tactic\u0026quot;]]\rmodels = modelparser.readproject(path, scenarios)\rglobalmodel = Models.FMTlpmodel(models[0], Models.FMTsolverinterface.CLP)\rglobalmodel.setparameter(Models.FMTintmodelparameters.LENGTH,int(args[\u0026quot;strategiclength\u0026quot;]))\rglobalmodel.setparameter(Models.FMTintmodelparameters.NUMBER_OF_THREADS,1)\rif \u0026quot;com\u0026quot; in args:\rfor firstperiod,value in [tuple(int(cmpt.split(\u0026quot;,\u0026quot;)[0]),float(cmpt.split(\u0026quot;,\u0026quot;)[1])) for cmpt in args[\u0026quot;com\u0026quot;]]:\rglobalmodel.setcompresstime(firstperiod,int(args[\u0026quot;strategiclength\u0026quot;]),value)\rstochastic = Models.FMTnssmodel(models[1],0)\rstochastic.setparameter(Models.FMTintmodelparameters.LENGTH, 1)\rlocalmodel = Models.FMTlpmodel(models[2], Models.FMTsolverinterface.CLP)\rlocalmodel.setparameter(Models.FMTintmodelparameters.LENGTH, 1)\rlocalmodel.setparameter(Models.FMTintmodelparameters.NUMBER_OF_THREADS,1)\rselectedoutputs=[]\rfor output in globalmodel.getoutputs():\rif output.getname() in args[\u0026quot;outputs\u0026quot;].split(\u0026quot;,\u0026quot;):\rselectedoutputs.append(output)\routputlocation = args[\u0026quot;folder\u0026quot;]\rlayersoptions=[\u0026quot;SEPARATOR=SEMICOLON\u0026quot;]\rreplanningtask=Parallel.FMTreplanningtask(globalmodel,stochastic, localmodel, selectedoutputs, outputlocation, \u0026quot;CSV\u0026quot;, layersoptions,int(args[\u0026quot;replicates\u0026quot;]),int(args[\u0026quot;replanninglength\u0026quot;]),0.5, Core.FMToutputlevel.totalonly)\rhandler = Parallel.FMTtaskhandler(replanningtask,int(args[\u0026quot;threads\u0026quot;]))\rhandler.setquietlogger()\rhandler.conccurentrun()\relse:\rprint(\u0026quot;FMT needs to be compiled with OSI\u0026quot;)\r2√®me partie : Cr√©ation des sc√©narios pour la replanification Pr√©paration Apr√®s avoir t√©l√©charg√© les fichiers d\u0026rsquo;exemples de FMT (voir plus haut), ouvrez le dossier Models/TWD_land/Scenarios/Globalex1.\nCe sc√©nario Globalex1 est un sc√©nario que nous utiliserons comme mod√®le strat√©gique ou mod√®le global.\nPrenez le temps d\u0026rsquo;observer le contenu de ses fichiers; en particulier, jetez un oeil √† ses actions, ses objectifs et ses contraintes.\nFaites de m√™me avec le mod√®le Localex1, que nous utiliserons comme mod√®le tactique ou mod√®le local.\nQuestion 1 Ouvrez ensuite une invite de commande de Windows, ou bien un Powershell. Utilisez la commande cd pour vous rendre dans le dossier Examples/Python/replanning. Puis, utilisez la commande suivante pour lancer la replannification :\npython Replanner.py -pri ../../Models/TWD_land/TWD_land.pri -str Globalex1 -tac Localex1 -sto Globalnofire -out OVOLREC,OSUPREC,OSUPPL,VOLINVENT -fol replanning_EX1 -rep 10 -len 20 -rel 20 -thr 2\rCette commande indique au script cr√©√© dans la premi√®re partie que nous voulons :\nUtiliser le mod√®le qui se trouve au chemin ../../Models/TWD_land/TWD_land.pri Utiliser le sc√©nario Globalex1 comme mod√®le strat√©gique Utiliser le sc√©nario Localex1 comme mod√®le tactique Utiliser le sc√©nario Globalnofire comme mod√®le stocastique Cr√©er des tableaux de sorties pour les outputs OVOLREC, OSUPREC, OSUPPL, et VOLINVENT Mettre ces tableaux dans le dossier replanning_EX1 Faire 10 it√©rations Solutionner le mod√®le strat√©gique sur 20 p√©riodes Faire la replannification sur 20 p√©riodes Utiliser 2 coeurs de CPU pour faire des it√©rations en parall√®le Une fois que la commande s\u0026rsquo;est √©x√©cut√©e, regardez les sorties pr√©sentes dans le dossier Examples/Python/replanning/replanning_EX1.\nAvec une tol√©rance √† la rupture de stock de 5%, quelle est la probabilit√© de maintenir OVOLREC jusqu‚Äô√† la p√©riode 10 dans le mod√®le tactique ?\nR√©v√©ler la correction Pour regarder la probabilit√© de maintenir OVOLREC au-dessus d\u0026rsquo;une baisse de 5%, il suffit de regarder le fichier outputsdrift.csv. Celui-ci nous indique la probabilit√© que les diff√©rents outputs s√©lectionn√©s restent, dans le mod√®le tactique, au-dessus ou en-dessous d\u0026rsquo;un certain √©loignement vis-√†-vis du mod√®le strat√©gique.\nOn peut donc ouvrir le fichier, et se rendre jusqu\u0026rsquo;aux lignes qui concernent OVOLREC et un drift de 0.05 (5%), √† savoir les lignes 462-481.\nEn regardant ces lignes, on peut voir qu\u0026rsquo;√† partir de la p√©riode 7, OVOLREC a une probabilit√© de 0 de ne pas baisser de plus de 5% par rapport au mod√®le strat√©gique (troisi√®me colonne LowerProbability); cette probabilit√© reste √† 0 pour toutes les p√©riodes suivantes. Ainsi, il semble donc que la probabilit√© de maintenir OVOLREC au-dessus d\u0026rsquo;une baisse de 5% jusqu\u0026rsquo;√† la p√©riode 10 est de 0.\nOn peut repr√©senter ces valeurs avec un graphe via les donn√©es de outputsdrift.csv :\nQuestion 2 √Ä pr√©sent, dupliquez le dossier Globalex1 et renommez-le Globalex2 (supprimez le dossier existant s\u0026rsquo;il existe d√©j√†).\nModifiez ensuite le fichier TWD_land.opt de Globalex2 afin de forcer le sc√©nario Globalex2 √† ne pas d√©passer 20 000 m¬≥ pour l\u0026rsquo;output OVOLREC.\nR√©v√©ler la correction Le contenu de TWD_land.opt du sc√©nario Globalex2 doit alors √™tre :\n*OBJECTIVE\r_MAXMIN oVolRec 1.._LENGTH\r*EXCLUDE\raCaribou 1.._LENGTH\rafire 1.._LENGTH\rarecup 1.._LENGTH\r*CONSTRAINTS\roVolRec\u0026lt;= 20000 1.._LENGTH\r_NDY(oVolRec) 1.._LENGTH\r*FORMAT MOSEK\rLancez ensuite une replannification avec le mod√®le strat√©gique Globalex2 et le mod√®le tactique Localex1, avec la commande suivante :\npython Replanner.py -pri ../../Models/TWD_land/TWD_land.pri -str Globalex2 -tac Localex1 -sto Globalnofire -out OVOLREC,OSUPREC,OSUPPL,VOLINVENT -fol replanning_EX2 -rep 10 -len 20 -rel 20 -thr 2\rUne fois que la commande s\u0026rsquo;est √©x√©cut√©e, regardez les sorties pr√©sentes dans le dossier Examples/Python/replanning/replanning_EX2.\nAvec une tol√©rance √† la rupture de stock de 5%, quelle est la probabilit√© de maintenir OVOLREC jusqu‚Äô√† la p√©riode 10 dans le mod√®le tactique ?\nY-as-t-il un gain vis-√†-vis de la question 1 ?\nR√©v√©ler la correction En regardant les r√©sultats de outputsdrift.csv, on peut voir que OVOLREC garde une probabilit√© de 1 de ne pas diminuer de plus de 5% tout du long des 20 p√©riodes. Ainsi, il y a une probabilit√© maximale que OVOLREC se maintiennent au-dessus de 5% de baisse dans le mod√®le tactique Localex1, lorsque l\u0026rsquo;on utilise le mod√®le strat√©gique Globalex2.\nOn a donc un gain clair vis-√†-vis de la question 1, pour laquelle OVOLREC ne pouvait pas se maintenir au-dessus d\u0026rsquo;une baisse de 5% √† partir de la 7i√®me p√©riode. Cela est surement d√ª au fait que l\u0026rsquo;on a forc√© Globalex2 √† ne pas r√©colter trop, ce qui a rendu le fait de maintenir ce niveau dans Localex1 plus facile.\nQuestion 3 √Ä pr√©sent, dupliquez le dossier Localex1 et renommez-le Localex3 (supprimez le dossier existant s\u0026rsquo;il existe d√©j√†).\nModifiez ensuite le fichier TWD_land.opt de Localex3 afin de forcer ce mod√®le tactique √† suivre la solution du mod√®le strat√©gique avec un poids de 100, avec le mot cl√© _SETGLOBALSCHEDULE(poids).\nR√©v√©ler la correction Le contenu de TWD_land.opt du sc√©nario Localex3 doit alors √™tre :\n*OBJECTIVE\r_MAX ovolrec 1.._LENGTH _SETGLOBALSCHEDULE(100)\r*EXCLUDE\raCaribou 1.._LENGTH\rafire 1.._LENGTH\rarecup 1.._LENGTH\r*CONSTRAINTS\roVolRec\u0026lt;= 40272 1.._LENGTH _SETFROMGLOBAL(1)\r*FORMAT MOSEK\rLancez ensuite une replannification avec le mod√®le strat√©gique Globalex1 et le mod√®le tactique Localex3, avec la commande suivante :\npython Replanner.py -pri ../../Models/TWD_land/TWD_land.pri -str Globalex1 -tac Localex3 -sto Globalnofire -out OVOLREC,OSUPREC,OSUPPL,VOLINVENT -fol replanning_EX3 -rep 10 -len 20 -rel 20 -thr 2\rUne fois que la commande s\u0026rsquo;est √©x√©cut√©e, regardez les sorties pr√©sentes dans le dossier Examples/Python/replanning/replanning_EX3.\nAvec une tol√©rance √† la rupture de stock de 5%, quelle est la probabilit√© de maintenir OVOLREC jusqu‚Äô√† la p√©riode 10 dans le mod√®le tactique ?\nY-as-t-il un gain vis-√†-vis de la question 1 ?\nR√©v√©ler la correction En regardant les r√©sultats de outputsdrift.csv dans Examples/Python/replanning/replanning_EX3, on peut voir que OVOLREC a une probabilit√© de 1 de ne pas diminuer de plus de 5% par rapport au mod√®le strat√©gique √† la p√©riode 8; mais que cette probabilit√© passe √† 0 √† partir de la p√©riode 9, et reste √† 0 pendant toutes les autres p√©riodes. Ainsi, il est certain que OVOLREC ne se maintiendra pas au-dessus d\u0026rsquo;une baisse de 5% jusqu\u0026rsquo;a la p√©riode 10.\nCependant, on peut quand m√™me observer un l√©ger gain par rapport √† la question 1; la probabilit√© que OVOLREC ne diminue pas de plus de 5% descendait √† 0 d√®s la p√©riode 7 dans ces r√©sultats. En poussant le mod√®le tactique √† suivre la solution du mod√®le strat√©gique avec le mot cl√© _SETGLOBALSCHEDULE(poids), on a donc gagn√© deux p√©riodes de stabilit√© en plus !\nQuestion 4 √Ä pr√©sent, dupliquez le fichier TWD_land._opt de Localex1 dans le dossier Localex4 (supprimez le fichier existant s\u0026rsquo;il existe d√©j√†).\nModifiez ensuite le fichier TWD_land.opt de Localex4 afin de forcer le mod√®le tactique √† suivre les tables de r√©plicas (PEUPLEMENT1.csv et PEUPLEMENT2.csv) pour la r√©colte dans les types de peuplement1 et peuplement2 (utilisez _REPLICATE()). En ce faisant, vous devez donc forcer le mod√®le tactique √† faire un certain niveau de r√©colte dans des entit√©s spatiales particuli√®res du mod√®le (les peuplements 1 et 2) en vous basant sur des fichiers que vous fournissez au mod√®le (PEUPLEMENT1.csv et PEUPLEMENT2.csv).\nR√©v√©ler la correction Le contenu de TWD_land.opt du sc√©nario Localex4 doit alors √™tre :\n*OBJECTIVE\r_MAX ovolrec - _Penalty(_All) 1.._LENGTH\r*EXCLUDE\raCaribou 1.._LENGTH\rafire 1.._LENGTH\rarecup 1.._LENGTH\r*CONSTRAINTS\roVolRec\u0026lt;= 40272 1.._LENGTH _SETFROMGLOBAL(1)\roVolRecPEUPLEMENT1 \u0026lt;= 0 1.._LENGTH _Goal(G1,9999) _REPLICATE(PEUPLEMENT1.csv)\roVolRecPEUPLEMENT1 \u0026gt;= 0 1.._LENGTH _Goal(G2,9999) _REPLICATE(PEUPLEMENT1.csv)\roVolRecPEUPLEMENT2 \u0026lt;= 0 1.._LENGTH _Goal(G3,9999) _REPLICATE(PEUPLEMENT2.csv)\roVolRecPEUPLEMENT2 \u0026gt;= 0 1.._LENGTH _Goal(G4,9999) _REPLICATE(PEUPLEMENT2.csv)\r*FORMAT MOSEK\rLancez ensuite une replannification avec le mod√®le strat√©gique Globalex1 et le mod√®le tactique Localex4, avec la commande suivante :\npython Replanner.py -pri ../../Models/TWD_land/TWD_land.pri -str Globalex1 -tac Localex4 -sto Globalnofire -out OVOLREC,OSUPREC,OSUPPL,VOLINVENT,OVOLRECPEUPLEMENT1,OVOLRECPEUPLEMENT2 -fol replanning_EX4 -rep 10 -len 20 -rel 20 -thr 2\rUne fois que la commande s\u0026rsquo;est √©x√©cut√©e, rendez vous dans le fichier Localex4.csv du dossier replanning_EX4, et observez les r√©sultats des outputs OVOLRECPEUPLEMENT1 et OVOLRECPEUPLEMENT2. En particulier, vous pouvez creer une table pivot dans un logiciel comme Microsoft Excel afin d\u0026rsquo;obtenir un graphe montrant l\u0026rsquo;√©volution de ces mesures √† travers les p√©riodes de temps, avec une courbe pour chacune des it√©rations.\nEn m√™me temps, ouvrez les fichiers PEUPLEMENT1.csv et PEUPLEMENT2.csv, et observez leur contenu. Chaque colonne correspond √† des valeurs que le mod√®le tactique devait suivre pour une it√©ration, avec chaque ligne contenant une valeur pour une p√©riode donn√©e.\nEn comparant le contenu de Localex4.csv et de PEUPLEMENT1.csv et PEUPLEMENT2.csv, qu\u0026rsquo;observez vous ?\nR√©v√©ler la correction On peut voir que le mod√®le tactique √† en effet suivi les niveaux de r√©colte d√©finit dans les fichiers PEUPLEMENT1.csv et PEUPLEMENT2.csv pour l\u0026rsquo;output OVOLREC dans les peuplements 1 et deux.\nEn particulier, on peut voir que OVOLRECPEUPLEMENT1 descend √† 0 pour la p√©riode 4 dans toutes les it√©rations, comme pr√©vu dans PEUPLEMENT1.csv. On peut aussi voir que l\u0026rsquo;it√©ration 4 garde une valeur de OVOLRECPEUPLEMENT1 √† 10 la plupart du temps, alors que les autres it√©rations gardent une valeur de 20.\nOn peut observer une baisse √† 0 pour OVOLRECPEUPLEMENT2 √† la p√©riode 9 dans toutes les it√©rations, comme pr√©vu dans PEUPLEMENT2.csv.\nQuestion 5 √Ä pr√©sent, dupliquez le dossier Localex1 et renommez-le Localex5 (supprimez le dossier existant s\u0026rsquo;il existe d√©j√†).\nModifiez ensuite le fichier TWD_land.opt de Localex5 afin de forcer ce mod√®le tactique √† ignorer la contrainte de plantation de 90 √† 100ha √† partir de la p√©riode (ou bien de ne la suivre que durant la p√©riode 1) en utilisant le mot cl√© _REIGNORE(p√©riode).\nR√©v√©ler la correction Le contenu de TWD_land.opt du sc√©nario Localex5 doit alors √™tre :\n*OBJECTIVE\r_MAX ovolrec - _Penalty(_All) 1.._LENGTH\r*EXCLUDE\raCaribou 1.._LENGTH\rafire 1.._LENGTH\rarecup 1.._LENGTH\r*CONSTRAINTS\roVolRec\u0026lt;= 40272 1.._LENGTH _SETFROMGLOBAL(1)\rosuppl \u0026gt;= 90 1 _Goal(G1,9999) _REIGNORE(2)\rosuppl \u0026lt;= 100 1 _Goal(G2,9999) _REIGNORE(2)\r*FORMAT MOSEK\rLancez ensuite une replannification avec le mod√®le strat√©gique Globalex1 et le mod√®le tactique Localex5, avec la commande suivante :\npython Replanner.py -pri ../../Models/TWD_land/TWD_land.pri -str Globalex1 -tac Localex5 -sto Globalnofire -out OVOLREC,OSUPREC,OSUPPL,VOLINVENT -fol replanning_EX5 -rep 10 -len 20 -rel 20 -thr 2\rUne fois que la commande s\u0026rsquo;est √©x√©cut√©e, comparez l\u0026rsquo;√©volution de l\u0026rsquo;output du niveau de plantations OSUPPL dans le mod√®le tactique Localex1 (dans le dossier replanning_EX1 cr√©√© √† la question 1) √† l\u0026rsquo;√©volution de OSUPPL dans le mod√®le tactique Localex5 (dans le dossier replanning_EX5). Comme pr√©c√©demment, vous pouvez utiliser une table pivot dans un logiciel comme Microsoft Excel afin d\u0026rsquo;obtenir un graphe montrant l\u0026rsquo;√©volution de ces mesures √† travers les p√©riodes de temps, avec une courbe pour chacune des it√©rations.\nQuelles diff√©rences observez-vous entre Localex1 et Localex5 ? ?\nR√©v√©ler la correction On peut voir que le mod√®le tactique Localex1 arrive √† soutenir le niveau de OSUPPL pendant un long moment de mani√®re stable, comme montr√© sur ce graphe :\nEn comparaison, dans Localex5, on peut voir que le niveau de OSUPPL est beaucoup plus variable et instable. Il atteind rapidement des valeurs de 0, √† cause du fait que les contraintes du mod√®le le concernant sont ignor√©es apr√®s la p√©riode 2, comme montr√© sur ce graphe :\nAinsi, il semble que le fait d\u0026rsquo;ignorer les contraintes concernant OSUPPL √† bien fonctionn√©.\nQuestion 6 √Ä pr√©sent, dupliquez le dossier Localex1 et renommez-le Localex6 (supprimez le dossier existant s\u0026rsquo;il existe d√©j√†).\nModifiez ensuite le fichier TWD_land.opt de Localex6 afin de forcer ce mod√®le tactique √† r√©aliser de 100% du niveau de r√©colte (OVOLREC) du mod√®le strat√©gique, avec une variabilit√© de 1% autoris√©e pour le d√©passement de la valeur (donc au moins 100%, et au plus 101%) avec le mot cl√© _SETFROMGLOBAL(poids).\nR√©v√©ler la correction Le contenu de TWD_land.opt du sc√©nario Localex6 doit alors √™tre :\n*OBJECTIVE\r_MAX ovolrec - _Penalty(_All) 1.._LENGTH\r*EXCLUDE\raCaribou 1.._LENGTH\rafire 1.._LENGTH\rarecup 1.._LENGTH\r*CONSTRAINTS\roVolRec\u0026lt;= 40272 1.._LENGTH _SETFROMGLOBAL(1)\rosuprec \u0026lt;= 40272 1.._LENGTH _Goal(G1,9999) _SETFROMGLOBAL(1.0)\rosuprec \u0026gt;= 40272 1.._LENGTH _Goal(G2,9999) _SETFROMGLOBAL(0.99)\r*FORMAT MOSEK\rLancez ensuite une replannification avec le mod√®le strat√©gique Globalex1 et le mod√®le tactique Localex6, avec la commande suivante :\npython Replanner.py -pri ../../Models/TWD_land/TWD_land.pri -str Globalex1 -tac Localex6 -sto Globalnofire -out OVOLREC,OSUPREC,OSUPPL,VOLINVENT -fol replanning_EX6 -rep 10 -len 20 -rel 20 -thr 2\rUne fois que la commande s\u0026rsquo;est √©x√©cut√©e, regardez les sorties pr√©sentes dans le dossier Examples/Python/replanning/replanning_EX6.\nComparez √† pr√©sent la probabilit√© de maintenir une r√©colte similaire √† l\u0026rsquo;exercice 1 (avec Localex1) en regardant le contenu de outputsdrift.csv dans replanning_EX1 et replanning_EX6.\nQuelles diff√©rences observez-vous ?\nR√©v√©ler la correction On observe que la probabilit√© de maintient de OVOLREC dans le mod√®le tactique au-dessus d\u0026rsquo;une diminution de 5% par rapport au mod√®le strat√©gique est relativement similaire entre Localex1 et Localex6; si ce n\u0026rsquo;est que Localex6 √† une valeur plus basse de cette probabilit√© √† la p√©riode 7, quand celle-ci chute vers 0.\nQuestion 7 √Ä pr√©sent, dupliquez le dossier Globalex1 et renommez-le Globalex7 (supprimez le dossier existant s\u0026rsquo;il existe d√©j√†).\nModifiez ensuite le fichier TWD_land.opt de Globalex7 afin de forcer le sc√©nario Globalex7 √† r√©aliser au moins 99% du niveau de r√©colte OVOLREC du mod√®le tactique.\nR√©v√©ler la correction Le contenu de TWD_land.opt du sc√©nario Globalex7 doit alors √™tre :\n*OBJECTIVE\r_MAXMIN oVolRec - _Penalty(_All) 1.._LENGTH\r*EXCLUDE\raCaribou 1.._LENGTH\rafire 1.._LENGTH\rarecup 1.._LENGTH\r*CONSTRAINTS\rosuprec \u0026lt;= 40272 1.._LENGTH _Goal(G1,9999) _SETFROMLOCAL(1.0)\rosuprec \u0026gt;= 40272 1.._LENGTH _Goal(G2,9999) _SETFROMLOCAL(0.99)\r_NDY(oVolRec) 1.._LENGTH\r*FORMAT MOSEK\rLancez ensuite une replannification avec le mod√®le strat√©gique Globalex7 et le mod√®le tactique Localex1, avec la commande suivante :\npython Replanner.py -pri ../../Models/TWD_land/TWD_land.pri -str Globalex7 -tac Localex1 -sto Globalnofire -out OVOLREC,OSUPREC,OSUPPL,VOLINVENT -fol replanning_EX7 -rep 10 -len 20 -rel 20 -thr 2\rUne fois que la commande s\u0026rsquo;est √©x√©cut√©e, regardez les sorties pr√©sentes dans le dossier Examples/Python/replanning/replanning_EX7.\nObservez √† pr√©sent comment se compare le maintient du niveau des plantations (output OSSUPL) entre ceux de la question 1, et ceux de cette replannification en regardant les fichiers outputsdrift.csv de replanning_EX1 et replanning_EX7.\nComment se comparent le maintient du niveau de OSSUPL par rapport √† la question 1 ?\nR√©v√©ler la correction On peut remarquer que pour la question 1 et cette question, OSSUPL garde une probabilit√© tr√®s basse de se maintenir au dela d\u0026rsquo;une grande diminution d√®s les premi√®res p√©riodes lorsque l\u0026rsquo;on compare le mod√®le tactique et strat√©gique.\nCependant, m√™me pour des valeurs de drifts tr√®s hautes (e.g. 50%), on peut voir que OSSUPL √† tendance √† avoir une plus haute probabilit√© de grandement diminuer sa valeur avec Globalex7 plutot qu\u0026rsquo;avec Globalex1.\n","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"fr","lastmod":1557010800,"objectID":"a485d0673d91147fe0dd1dafb10bd03d","permalink":"https://bureau-du-forestier-en-chef.github.io/FMTdocs/fr/docs/advanced/exercice_2/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/FMTdocs/fr/docs/advanced/exercice_2/","section":"docs","summary":"Dans cet exercice, vous allez essayer d\u0026rsquo;utiliser FMT pour r√©pondre √† diff√©rentes questions concernant un mod√®le strat√©gique et un mod√®le tactique, par le biais d\u0026rsquo;un processus de replanification.\nAinsi, cet exercice vous apprendra √† :","tags":null,"title":"Exercice 2","type":"book"},{"authors":null,"categories":null,"content":"Que sont les objets ? FMT est fabriqu√© avec une structure particuli√®re appel√©e Programmation orient√©e objet (POO). Si vous n\u0026rsquo;en avez jamais entendu parler, en voici un r√©sum√© tr√®s rapide pour mieux comprendre comment utiliser FMT.\nDans l\u0026rsquo;approche POO ou Object oriented programming en anglais (OOP), le programme utilise diff√©rents \u0026ldquo;objets\u0026rdquo; qui ont une certaine \u0026ldquo;classe\u0026rdquo; et qui peuvent avoir diff√©rentes \u0026ldquo;fonctions\u0026rdquo;.\nVous connaissez et utilisez peut-√™tre d√©j√† des fonctions dans des logiciels tels que \u0026ldquo;R\u0026rdquo;. Par exemple, dans R, plot() est une fonction.\nVous pourriez √©galement √™tre habitu√©.e √† certains objets et classes dans le logiciel que vous utilisez. Par exemple, dans R, data\u0026lt;-read.csv (donn√©es.csv) met le contenu des donn√©es.fichier csv dans l\u0026rsquo;objet data, qui a la classe data frame.\nMaintenant, imaginez que chaque fonction que vous utilisez est associ√©e √† un objet d\u0026rsquo;une classe particuli√®re. Par exemple, une classe chien aurait la fonction aboyer_sur(). Si nous avons une classe nomm√©e chat, nous pourrions alors :\nCr√©er un nouvel objet chien de la classe chien : pluto = chien(nom = Pluto, age = 8) Cr√©er un nouvel objet chat √† partir de la classe chat : felix = chat(nom = Felix, age = 2) Faire aboyer le chien sur le chat: pluto.aboyer_sur(felix) √Ä son tour, l\u0026rsquo;objet peut avoir des \u0026ldquo;propri√©t√©s\u0026rdquo;, qui sont exactement ce √† quoi cela ressemble. Par exemple, disons que notre classe chat a trois propri√©t√©s : nom (qui peut √™tre une cha√Æne de caract√®res), age (qui peut √™tre un nombre) et effray√© (qui est un bool√©en, true ou false).\nDans notre exemple pr√©c√©dent, avant d\u0026rsquo;utiliser pluto.aboyer_sur(felix), la propri√©t√© felix.peur pouvait √™tre false. Mais maintenant que nous avons utilis√© pluto.aboyer_sur(felix), felix.peur s\u0026rsquo;est surement chang√© en true.\nEnfin, une classe parent en programmation orient√©e objet signifie que la classe enfant h√©ritera automatiquement de toutes les fonctions et propri√©t√©s de la fonction parent.\nPar exemple, supposons que nous ayons une classe parent animal dont d√©rivent les classes chien et chat. Si la classe animal a une fonction respiration (animal.respiration()), alors les classes chien et chat √©tant ses classes enfant, elles auront automatiquement cette fonction (chien.respiration()) et chat.respiration()).\nLa programmation orient√©e objet est une fa√ßon particuli√®re de programmer, int√©gr√©e dans le langage de programmation que vous utilisez, qui pr√©sente de multiples avantages. L\u0026rsquo;un d\u0026rsquo;eux est de rendre les choses plus faciles √† repr√©senter.\nEn bref : FMT utilise la programmation orient√©e objet, ce qui fait de tout un objet avec des fonctions particuli√®res. Les fonctions et propri√©t√©s d\u0026rsquo;un objet sont d√©finies par sa classe.\nPour apprendre √† utiliser FMT, vous apprendrez quelles sont ses classes principales, afin que vous puissiez cr√©er les objets dont vous avez besoin et les faire interagir pour faire les choses que vous voulez faire. En effet, que ce soit en Python, R ou C ++, utiliser FMT signifie utiliser ses diff√©rents objets.\nLes namespaces de FMT Les diff√©rentes classes d\u0026rsquo;objets dans FMT sont regroup√©es en espaces de noms (namespaces), qui sont simplement les diff√©rentes sections de ses fichiers.\nDans FMT, les diff√©rents espaces de noms sont :\nParser : Contient des classes utilis√©es pour lire ou √©diter les fichiers des mod√®les au format Woodstock Models: Contient des classes utilis√©es pour manipuler et r√©soudre les mod√®les Spatial: Contient des classes utilis√©es pour travailler sur des donn√©es spatialement explicites Heuristics : Contient les heuristiques utilis√©es pour agr√©ger spatialement les blocs de coupes et les planifier dans le temps Version: Contient des informations sur la version actuelle de FMT, et les fonctions qu\u0026rsquo;elle contient (ce qui d√©pend de la fa√ßon dont il a √©t√© compil√©e) Si vous regardez l\u0026rsquo;[importation de FMT dans Python](../../download_install/importing_in_python /), vous verrez que nous importons les principaux espaces de noms dont vous aurez besoin en Python. Classes importantes de l\u0026rsquo;espace de noms Parser L\u0026rsquo;espace de noms Parser contient deux classes importantes pour la lecture des mod√®les :\nFMTareaparser : Permet la lecture et l\u0026rsquo;√©criture des fichiers raster et vectoriels utilis√©s dans les op√©rations spatiales de FMT Certaines de ses fonctions vous permettent de transformer des donn√©es entre le format vectoriel et le format raster. FMTmodelparser : Permet de lire les fichiers d\u0026rsquo;un mod√®le Woodstock avec la fonction read project(), ou de l\u0026rsquo;enregistrer avec la fonction write() apr√®s l\u0026rsquo;avoir modifi√©. La classe utilise √©galement d\u0026rsquo;autres classes faites pour lire les fichiers Woodstock. La classe FMTmodel La classe FMTmodel est la base de FMT.\nElle contient des informations provenant des fichiers des mod√®les au format Woodstock. Cela peut √™tre vu en regardant les propri√©t√©s du FMTmodel :\nCependant, ces attributs sont \u0026ldquo;prot√©g√©s\u0026rdquo; afin qu\u0026rsquo;ils ne soient pas modifi√©s de mani√®re incorrecte. Si vous souhaitez les lire lors de l\u0026rsquo;utilisation de FMT, vous devrez utiliser les fonctions getter qui les obtiendront pour vous :\nDe plus, vous pouvez les modifier de la bonne mani√®re en utilisant les fonctions setter. Cela vous permet d\u0026rsquo;√©diter diff√©rentes parties du mod√®le.\nEn fin de compte, le FMTModel est ce que nous appelons une classe parent pour toutes les diff√©rentes classes de mod√®les utilis√©es par FMT, telles que FMTlpmodel (mod√®le de programmation lin√©aire) et FMTsesmodel (mod√®le spatialement explicite) selon le diagramme suivant :\nclassDiagram\rFMTobject \u0026lt;|-- FMTmodel\rFMTmodel \u0026lt;|-- FMTsemodel\rFMTsemodel \u0026lt;|-- FMTsamodel\rFMTsemodel \u0026lt;|-- FMTsesmodel\rFMTmodel \u0026lt;|-- FMTsrmodel\rFMTsrmodel \u0026lt;|-- FMTlpmodel\rFMTsrmodel \u0026lt;|-- FMTnssmodel\rObservez que toutes ces classes h√©ritent finalement de la classe FMTobject. C\u0026rsquo;est le cas pour chaque objet de FMT, car FMTobject contient des fonctions et des propri√©t√©s utiles pour d√©boguer FMT.\nLes mod√®les FMTnssmodel et FMTlpmodel sont des mod√®les r√©f√©renc√©s spatialement FMTsrmodel. Le FMTlpmodel est utilis√© pour l\u0026rsquo;optimisation, tandis que FMTnssmodel est utilis√© pour la simulation.\nEn contraste, les mod√®les FMTsesmodel et FMTsamodel sont des mod√®les spatialement explicites FMTsemodel. De la m√™me mani√®re, FMTsamodel est utilis√© pour l\u0026rsquo;optimisation, tandis que FMTsesmodel est utilis√© pour la simulation.\nNous examinerons de plus pr√®s les diff√©rents types de mod√®les plus tard. Pour l\u0026rsquo;instant, nous n\u0026rsquo;utiliserons que le mod√®le le plus simple qui correspond le plus √† une structure de mod√®le de Woodstock, le FMTlpmodel.\nLire un simple FMTlpmodel Voici un exemple qui permet de lire un mod√®le de programmation lin√©aire (au format Woodstock) avec FMT.\nEn R, le code pour correspondant serait :\nlibrary(FMT) # Charge FMT dans R\rif (new(FMTversion)$hasfeature(\u0026quot;OSI\u0026quot;)) # V√©rifie si FMT a √©t√© compil√© avec OSI en cr√©ant un nouvel objet FMTversion, et en utilisant la fonction hasfeature().\r{\r# Cr√©er un objet parser pour lire les fichiers du mod√®le\rnewmodelparser \u0026lt;- new(FMTmodelparser)\r# Lit le projet avec le parser en sp√©cifiant que l'on veut lire le sc√©nario \u0026quot;LP\u0026quot; (il peut y avoir diff√©rents sc√©narios dans un seul mod√®le)\rmodelslist \u0026lt;- newmodelparser$readproject(\u0026quot;Models/TWD_land/TWD_land.pri\u0026quot;, c(\u0026quot;LP\u0026quot;), TRUE, TRUE, TRUE)\rmodel_scenario_lp \u0026lt;- modelslist[[1]]\r# On r√©cup√®re le nom du mod√®le\rprint(model_scen_lp$getname())\r} else { # Si le mod√®le n'as pas √©t√© compil√© avec OSI, on affiche une erreur\rprint(\u0026quot;FMT needs to be compiled with OSI\u0026quot;)\r}\rDans Python, le m√™me code aurait la forme suivante :\nimport sys\rfrom FMT import Models\rfrom FMT import Parser\rfrom FMT import Version\rif __name__ == \u0026quot;__main__\u0026quot;:\rif Version.FMTversion().hasfeature(\u0026quot;OSI\u0026quot;): # V√©rifie si FMT a √©t√© compil√© avec OSI en utilisant la fonction hasfeature() de la classe FMTversion.\r# Cr√©er un objet parser pour lire les fichiers du mod√®le\rnewmodelparser= Parser.FMTmodelparser()\rpath = \u0026quot;Models/TWD_Land/TWD_Land.pri\u0026quot;\rscenarios = [\u0026quot;LP\u0026quot;]\r# Lit le projet avec le parser en sp√©cifiant que l'on veut lire le sc√©nario \u0026quot;LP\u0026quot; (il peut y avoir diff√©rents sc√©narios dans un seul mod√®le)\rmodelslist = newmodelparser.readproject(path, scenarios)\rmodel_scen_lp = modelslist[0]\r# On r√©cup√®re le nom du mod√®le\rprint(model_scen_lp.getname())\relse:\r# Si le mod√®le n'as pas √©t√© compil√© avec OSI, on affiche une erreur\rprint(\u0026quot;FMT needs to be compiled with OSI\u0026quot;)\rQue ce soit dans le terminal de R ou de Python, les codes pr√©c√©dents devraient affichier la m√™me chose :\nReading Models/TWD_land/TWD_land.pri\rFMT 0.9.1, build: Sep 30 2021 12:07:49\rTue Oct 05 10:59:57 2021\rReading Scenario Lp\rFMTexc(39)Undefined _death action: _DEATH FMTsection(4)Action\rFMTexc(40)Undefined _death transition: _DEATH FMTsection(5)Transition\rDone reading Tue Oct 05 10:59:57 2021\r[1] \u0026quot;LP\u0026quot;\rComme on peut le voir, FMT indique qu\u0026rsquo;il a lu le sc√©nario \u0026ldquo;LP\u0026rdquo;, et il affiche son nom.\nL\u0026rsquo;espace de noms Core. L\u0026rsquo;espace de nom Core contient les √©l√©ments utilis√©s par FMT \u0026ldquo;sous le capot\u0026rdquo; pour faire fonctionner l\u0026rsquo;objet FMTModel.\nPar exemple, il contient les objets :\nFMTaction : Classe qui d√©finit l\u0026rsquo;op√©rabilit√© de plusieurs strates pour une perturbation donn√©e. FMTtransition : Classe qui d√©finit les transitions de strates multiples pour une perturbation donn√©e. FMTyields : Classe qui d√©finit les valeurs de croissance et de rendement pour chaque strate. FMToutputs : Classe qui d√©finit les sorties dans le mod√®le (inventaire ou action), mais pas les sorties du mod√®le (par exemple, les fichiers de sortie ou autres). FMTconstraints : Classe qui d√©finit les contraintes globales et l\u0026rsquo;objectif du mod√®le (par exemple, la variable √† optimiser). Ces diff√©rents objets peuvent √™tre appel√©s depuis un objet FMTmodel avec les diff√©rentes fonctions getter.\nPar exemple, pour voir la liste des objets FMTaction associ√©s √† un FMTmodel particulier, vous pouvez utiliser la fonction FMTModel.getactions() (ou FMTModel$getactions() en R), et utiliser une boucle for pour afficher toutes les actions dans le mod√®le. Les actions affich√©es de cette mani√®re correspondront aux actions pr√©sentes dans le fichier .act des fichiers Woodstock pour le mod√®le.\nVoici un exemple qui affiche les actions et les transitions d\u0026rsquo;un FMTmodel en code R :\nlibrary(FMT) # Charge FMT dans R\rif (new(FMTversion)$hasfeature(\u0026quot;OSI\u0026quot;)) # V√©rifier si FMT a √©t√© compil√© avec OSI en cr√©ant un nouvel objet FMTversion, et en utilisant la fonction hasfeature().\r{\r# Cr√©er un objet parser pour lire les fichiers du mod√®le\rnewmodelparser \u0026lt;- new(FMTmodelparser)\r# Lit le projet avec le parser en sp√©cifiant que l'on veut lire le sc√©nario \u0026quot;LP\u0026quot; (il peut y avoir diff√©rents sc√©narios dans un seul mod√®le)\rmodelslist \u0026lt;- newmodelparser$readproject(\u0026quot;Models/TWD_land/TWD_land.pri\u0026quot;, c(\u0026quot;LP\u0026quot;), TRUE, TRUE, TRUE)\rmodel \u0026lt;- modelslist[[1]]\r# R√©cup√®re le actions du mod√®le et les affiche\rprint(\u0026quot;***** Here is the name of the actions\u0026quot;)\rfor (action in model$getactions())\r{\rprint(action$getname())\r}\r# On fait de m√™me pour les transitions\rprint(\u0026quot;***** Here is the name of the transitions\u0026quot;)\rfor (transition in model$gettransitions())\r{\r# On concat√®ne l'entr√©e pour la transition afin de la rendre plus lisible dans le terminal\rcat(transition$str())\r}\r} else { # Si le mod√®le n'as pas √©t√© compil√© avec OSI, on affiche une erreur\rprint(\u0026quot;FMT needs to be compiled with OSI\u0026quot;)\r}\rCe code en R affichera le texte suivant dans le terminal :\nReading Models/TWD_land/TWD_land.pri\rFMT 0.9.1, build: Sep 30 2021 12:07:49\rTue Oct 05 10:59:57 2021\rReading Scenario Lp\rFMTexc(39)Undefined _death action: _DEATH FMTsection(4)Action\rFMTexc(40)Undefined _death transition: _DEATH FMTsection(5)Transition\rDone reading Tue Oct 05 10:59:57 2021\r[1] \u0026quot;***** Here is the name of the actions\u0026quot;\r[1] \u0026quot;CLEARCUT\u0026quot;\r[1] \u0026quot;ACARIBOU\u0026quot;\r[1] \u0026quot;PLANTATION\u0026quot;\r[1] \u0026quot;AFIRE\u0026quot;\r[1] \u0026quot;ARECUP\u0026quot;\r[1] \u0026quot;_DEATH\u0026quot;\r[1] \u0026quot;***** Here is the name of the transitions\u0026quot;\r*CASE CLEARCUT\r*SOURCE ? ? ?\r*TARGET ? ? ? 100.000000\r*CASE ACARIBOU\r*SOURCE ? ? ?\r*TARGET ? ? ? 100.000000 _LOCK 1\r*CASE PLANTATION\r*SOURCE ? ? ?\r*TARGET ? STAND1 ? 100.000000\r*CASE AFIRE\r*SOURCE ? ? ?\r*TARGET ? FIRE ? 100.000000\r*CASE ARECUP\r*SOURCE ? FIRE ?\r*TARGET ? STAND1 ? 100.000000\r*CASE _DEATH\r*SOURCE ? ? ?\r*TARGET ? ? ? 100.000000\rL\u0026rsquo;√©quivalent en Python serait :\nimport sys\rfrom FMT import Models\rfrom FMT import Parser\rfrom FMT import Version\rif __name__ == \u0026quot;__main__\u0026quot;:\rif Version.FMTversion().hasfeature(\u0026quot;OSI\u0026quot;):\r# Cr√©er un objet parser pour lire les fichiers du mod√®le\rnewmodelparser= Parser.FMTmodelparser()\rpath = \u0026quot;Models/TWD_Land/TWD_Land.pri\u0026quot;\rscenarios = [\u0026quot;LP\u0026quot;]\r# Lit le projet avec le parser en sp√©cifiant que l'on veut lire le sc√©nario \u0026quot;LP\u0026quot; (il peut y avoir diff√©rents sc√©narios dans un seul mod√®le)\rmodelslist = newmodelparser.readproject(path, scenarios)\rmodel = modelslist[0]\r# R√©cup√®re le actions du mod√®le et les affiche\rprint(\u0026quot;***** Here is the name of the actions\u0026quot;)\rfor action in model.getactions():\rprint(action)\r# On fait de m√™me pour les transitions\rprint(\u0026quot;***** Here is the name of the transitions\u0026quot;)\rfor transition in model.gettransitions():\rprint(transition.getname())\relse:\rprint(\u0026quot;FMT needs to be compiled with OSI\u0026quot;)\rCe qui donnera le texte suivant dans le terminal Python. Notez que si les sorties entre R et Python devraient g√©n√©ralement √™tre les m√™mes, il existe parfois de petites diff√©rences. Ici, la version Python affichera plus d\u0026rsquo;informations sur les actions, et juste le nom des transitions par rapport √† R ; ceci est d√ª aux particularit√©s des deux langages.\nReading Models/TWD_land/TWD_land.pri\rFMT 0.9.1, build: Sep 30 2021 12:07:49\rTue Oct 05 10:59:57 2021\rReading Scenario Lp\rFMTexc(39)Undefined _death action: _DEATH FMTsection(4)Action\rFMTexc(40)Undefined _death transition: _DEATH FMTsection(5)Transition\rDone reading Tue Oct 05 10:59:57 2021\r***** Here is the name of the actions\r*ACTION CLEARCUT Y\r*OPERABLE COUPETOTALE\r? ? ? TOTALVOLUME \u0026gt;= 100.000000\r*ACTION ACARIBOU N\r*OPERABLE ACARIBOU\rUC ? ? _AGE \u0026gt;= 8\r*ACTION PLANTATION Y _LOCKEXEMPT\r*OPERABLE PLANTATION\r? ? ? _AGE \u0026gt;= 1 AND _AGE \u0026lt;= 3\r*ACTION ARECUP Y\r*OPERABLE AFIRE\r? PROD ? _AGE \u0026gt;= 1\r*ACTION ARECUP Y\r*OPERABLE ARECUP\r? FEU ? _AGE = 0\r*ACTION _DEATH Y _LOCKEXEMPT\r*OPERABLE _DEATH\r? ? ? _AGE \u0026gt;= 80\r***** Here is the name of the transitions\rCLEARCUT\rACARIBOU\rPLANTATION\rAFIRE\rARECUP\r_DEATH\rComparer des √©l√©ments dans FMT Une op√©ration courante √† faire dans vos scripts sera de comparer des √©l√©ments : par exemple, comparer le nom d\u0026rsquo;un objet FMTaction avec le nom de l\u0026rsquo;action que vous voulez s√©lectionner, etc.\nDans de tels cas, rappelez-vous que toutes les cha√Ænes de caract√®res lues par FMT sont automatiquement mises en majuscules. Par cons√©quent, si vous voulez comparer le nom des √©l√©ments dans FMT, assurez-vous que les lettres sont en majuscules.\nPar exemple, si vous avez une action nomm√©e Clearcut ou clearcut que vous voulez s√©lectionner, vous devrez comparer le nom des FMTactions des mod√®les avec le mot CLEARCUT, tout en majuscules.\nConversion des erreurs en avertissements Toutes les classes FMT h√©ritent de la classe FMTobject, et partagent donc les m√™mes objets FMTexceptionhandler et FMTlogger.\nSi l\u0026rsquo;utilisateur veut ignorer certaines erreurs, il peut utiliser la fonction seterrorstowarnings de n\u0026rsquo;importe quelle classe FMT et passer un vecteur d\u0026rsquo;erreurs que le gestionnaire d\u0026rsquo;erreurs doit consid√©rer comme des avertissements. Cette fonction est hazardeuse et peux mener a des erreurs. Il est recommand√© d\u0026rsquo;investiguer les messages d\u0026rsquo;erreur de FMT et de corriger les mod√®les cons√©quement.\nMaintenant que vous savez tout sur la structure de FMT et ses √©l√©ments de base, nous allons voir comment faire de l\u0026rsquo;optimisation √† r√©f√©rence spatiale avec elle, qui est l\u0026rsquo;une des principales fonctions de FMT.\n","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"fr","lastmod":1557010800,"objectID":"28124c8adfcb86aa5fb7c74a49d23b63","permalink":"https://bureau-du-forestier-en-chef.github.io/FMTdocs/fr/docs/basics/objects_parsing_interrogation/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/FMTdocs/fr/docs/basics/objects_parsing_interrogation/","section":"docs","summary":"Que sont les objets ? FMT est fabriqu√© avec une structure particuli√®re appel√©e Programmation orient√©e objet (POO). Si vous n\u0026rsquo;en avez jamais entendu parler, en voici un r√©sum√© tr√®s rapide pour mieux comprendre comment utiliser FMT.","tags":null,"title":"Objets, lecture et interrogation de mod√®les","type":"book"},{"authors":null,"categories":null,"content":" T√©l√©charger et installer Visual Studio Community Lors de l\u0026rsquo;installation de Visual Studio Community, n\u0026rsquo;oubliez pas d\u0026rsquo;indiquer pendant l\u0026rsquo;installation que vous voulez que l\u0026rsquo;outil de compilation Cmake soit install√©. Visual Studio Community est la version gratuite du logiciel Visual Studio de Microsoft. Nous l\u0026rsquo;utiliserons plus tard pour compiler FMT, car il est install√© avec un compilateur compatible avec Windows. T√©l√©chargez et installez Mosek Mosek est un solveur pour les probl√®mes de programmation lin√©aire, qui est exactement le type de probl√®mes que traite FMT. Cependant, FMT peut fonctionner avec diff√©rents autres solveurs, libres ou non. Cr√©ez un dossier FMT-Installation dans votre ordinateur. Assurez-vous qu\u0026rsquo;il n\u0026rsquo;y a pas d\u0026rsquo;espaces ou d\u0026rsquo;accents dans le chemin menant au dossier. Les espaces et les accents dans le chemin peuvent causer des erreurs avec diff√©rents programmes et diff√©rentes √©tapes de la compilation. C\u0026rsquo;est embettant, mais c\u0026rsquo;est comme √ßa ! Ouvrez une invite de commande, et utilisez la commande cd pour naviguer dans le dossier FMT-Installation. Pour ouvrir l\u0026rsquo;invite de commande sous Windows 10, appuyez simplement sur la touche , tapez cmd, puis appuyez sur Entr√©e.\nLa commande cd est utilis√©e pour changer le dossier √† l\u0026rsquo;int√©rieur duquel l\u0026rsquo;invite de commande est pr√™te √† agir.\nTapez cd .. pour aller dans le dossier parent de celui dans lequel vous √™tes, et cd dossier pour aller dans un dossier.\n","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"fr","lastmod":1557010800,"objectID":"b66c69f45a1514d17932505c1f981ea0","permalink":"https://bureau-du-forestier-en-chef.github.io/FMTdocs/fr/docs/download_install/prerequisits/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/FMTdocs/fr/docs/download_install/prerequisits/","section":"docs","summary":"T√©l√©charger et installer Visual Studio Community Lors de l\u0026rsquo;installation de Visual Studio Community, n\u0026rsquo;oubliez pas d\u0026rsquo;indiquer pendant l\u0026rsquo;installation que vous voulez que l\u0026rsquo;outil de compilation Cmake soit install√©. Visual Studio Community est la version gratuite du logiciel Visual Studio de Microsoft.","tags":null,"title":"Pr√©requis","type":"book"},{"authors":null,"categories":null,"content":"Dans la section pr√©c√©dente, nous avons vu comment lire un mod√®le Woodstock et le charger dans un objet FMTlpmodel.\nFMTlpmodel vous permettra de r√©soudre un mod√®le de programmation lin√©aire √† spatialement r√©f√©renc√©, ce qui vous donnera un calendrier (schedule) optimis√© d\u0026rsquo;op√©rations foresti√®res en fonction d\u0026rsquo;un objectif et d\u0026rsquo;un ensemble de contraintes.\nIci, nous allons voir comment r√©aliser cette optimisation en pratique.\nUn petit rappel sur la signification de \u0026ldquo;spatialement r√©f√©renc√©\u0026rdquo;. On peut distinguer 3 fa√ßons de prendre en compte l\u0026rsquo;espace dans un mod√®le :\nDans un mod√®le non spatial ou mod√®le spatialement implicite, les entit√©s (par exemple, les for√™ts, les animaux, les agents, etc.) ne sont pas directement associ√©es √† une position dans l\u0026rsquo;espace, mais la relation entre elles dans le mod√®le peut impliquer que seules certaines d\u0026rsquo;entre elles interagissent entre elles de mani√®re √† mimer une disposition spatiale. Dans un mod√®le spatialement r√©f√©renc√©, les entit√©s sont associ√©es √† des r√©gions de l\u0026rsquo;espace, mais pas √† une position pr√©cise dans ces r√©gions ; ces r√©gions peuvent √™tre non-continues. Les mod√®les de Woodstock sont par nature spatialement r√©f√©renc√©s, car ils consid√®rent des strates qui correspondent √† des for√™ts de m√™me composition et de m√™me √¢ge, qui peuvent √™tre dispers√©es en de nombreux endroits du paysage. Dans un mod√®le spatialement explicite, les entit√©s sont associ√©es √† des coordonn√©es pr√©cises dans l\u0026rsquo;espace, comme dans les pixels d\u0026rsquo;une carte matricielle. La structure du FMTlpmodel : FMTgraph et FMTdevelopment FMTlpmodel, FMTgraph et FMTdevelopment sont trois classes qui sont importantes pour comprendre comment un mod√®le de programmation lin√©aire est repr√©sent√© dans FMT, et comment le r√©soudre.\nFMTlpmodel est un mod√®le de planification foresti√®re √† programmation lin√©aire de type III, qui est spatialement r√©f√©renc√©.\nIl peut r√©soudre un mod√®le de planification foresti√®re de type III, et obtenir un calendrier de r√©colte optimal en utilisant les contraintes et les objectifs d√©finis par l\u0026rsquo;utilisateur.\nLa notion de type I, II et III des mod√®les de planification foresti√®re correspond √† une taxonomie particuli√®re relative √† leur structure math√©matique, et √† la mani√®re dont ils peuvent √™tre r√©solus. Les mod√®les de planification foresti√®re de type III sont actuellement les plus avanc√©s, et peuvent √™tre r√©solus pour de grands paysages avec beaucoup de surface foresti√®re. Vous pouvez en apprendre davantage √† leur sujet en lisant cet article. Le FMTlpmodel contient un objet appel√© FMTgraph, qui contient le graphe du mod√®le. Le graphe est un ensemble de noeuds reli√©s entre eux par des liens. Chaque noeud correspond √† un √©tat possible pour une strate particuli√®re (qui sont des groupes de peuplements forestiers r√©f√©renc√©s dans l\u0026rsquo;espace avec les m√™mes caract√©ristiques), et chaque lien repr√©sente une fa√ßon particuli√®re dont elle peut √©voluer vers un autre √©tat dans la m√™me p√©riode de temps et entre les p√©riodes.\nVoici une repr√©sentation visuelle d\u0026rsquo;un FMTgraph simple, dans lequel une strate particuli√®re peut √©voluer √† partir de diff√©rents √©tats (objets FMTdevelopment) avec diff√©rentes transitions caus√©es par diff√©rentes actions √† travers la m√™me p√©riode de temps. L\u0026rsquo;√©volution des strates se fait entre les p√©riodes et consiste √† augmenter l\u0026rsquo;√¢ge de ces derni√®res de 1 :\nUn FMTdevelopment est une classe importante de FMT. Elle repr√©sente une strate particuli√®re, c\u0026rsquo;est-√†-dire un peuplement forestier particulier qui a une composition et un √¢ge donn√©s, et qui existe √† une p√©riode donn√©e.\nPar cons√©quent, l\u0026rsquo;objet FMTdevelopment est associ√© √† un objet FMTmask, qui d√©crit l\u0026rsquo;ensemble des attributs (FMTtheme) qui d√©finit le FMTdevelopment. Ceci est illustr√© sur le visuel suivant :\nFMTdevelopment est la classe parente de deux classes, FMTactualdevelopment et FMTfuturdevelopment. Un FMTactualdevelopment repr√©sente toujours une strate en d√©but d\u0026rsquo;horizon de planification et contient donc l\u0026rsquo;information de la superficie de la strate. Les FMTfuturdevelopment sont les futurs possibles et donc aucune superficie ne leur est attribu√©e au d√©part. C\u0026rsquo;est le r√©sultat de l\u0026rsquo;optimisation qui nous informe sur la r√©partitions future des superficies au travers du FMTgraph.\nVoici ici quelques fonctions de la classe FMTdevelopment qui peuvent √™tre importantes pour manipuler le mod√®le √† diff√©rente fins :\nFMTdevelopment.grow() peut faire grandir le peuplement pour voir ce qu\u0026rsquo;il va devenir. Renvoie un FMTfuturdevelopment identique au FMTdevelopment √† partir duquel la fonction est appel√©e mais avec un √¢ge augment√© de 1 FMTdevelopment.operable() peut tester si une action donn√©e peut √™tre appliqu√©e √† ce d√©veloppement, sur la base d\u0026rsquo;une section de yield(une variable particuli√®re, par exemple) FMTdevelopment.operate() peut faire diff√©rentes actions sur la strate, et retourner un vecteur de FMTdevelopmentpath. Maintenant, nous pouvons regarder comment construire le \u0026ldquo;graphe complet\u0026rdquo; du mod√®le, qui est n√©cessaire pour r√©soudre le FMTlpmodel.\nConstruire le graphe complet du mod√®le Le graphe complet du mod√®le peut √™tre construit via une r√©p√©tition de la fonction FMTlpmodel.buildperiod(). Ceci est essentiel pour r√©soudre le mod√®le, car FMT va naviguer dans ce graphe pour trouver la solution optimale en fonction de l\u0026rsquo;objectif et des contraintes que nous allons fixer (voir section suivante).\nCette fonction n√©cessite trois param√®tres :\nUn planning d\u0026rsquo;actions, sous la forme d\u0026rsquo;un objet FMTschedule (il peut √™tre vide pour obtenir le graphe complet du mod√®le, contenant toutes les possibilit√©s). Une option pour forcer une construction partielle du graphe (que nous ne verrons pas pour l\u0026rsquo;instant) Un autre param√®tre pour l\u0026rsquo;op√©rabilit√© de la classe (que nous ne verrons pas non plus pour l\u0026rsquo;instant, et juste mis √† 1) Voici le code pour construire le graphe complet dans R. Notez la boucle for qui construit les diff√©rentes p√©riodes.\nlibrary(FMT) # Charge FMT dans R\rif (new(FMTversion)$hasfeature(\u0026quot;OSI\u0026quot;)) # V√©rifie si FMT a √©t√© compil√© avec OSI en cr√©ant un nouvel objet FMTversion, et en utilisant la fonction hasfeature().\r{\r# Cr√©ation de l'objet parser pour lire les fichiers de mod√®le\rnewparser \u0026lt;- new(FMTmodelparser)\r# Lit le projet avec le parser en sp√©cifiant que l'on veut lire le sc√©nario \u0026quot;LP\u0026quot; (il peut y avoir diff√©rents sc√©narios dans un seul mod√®le)\rmodelslist \u0026lt;- newmodelparser$readproject(\u0026quot;Models/TWD_land/TWD_land.pri\u0026quot;, c(\u0026quot;LP\u0026quot;), TRUE, TRUE, TRUE)\r# On met le mod√®le dans le format \u0026quot;lpmodel\u0026quot; pour le mod√®le de programmation lin√©aire, en sp√©cifiant le solveur que nous voulons utiliser\rsolverinterface \u0026lt;- list(CLP=1,MOSEK=2,CPLEX=3,GUROBI=4)\rlpmodel \u0026lt;- new(FMTlpmodel,modelslist[[1]],solverinterface$MOSEK)\r# Nous cr√©ons un calendrier vide pour cr√©er le graphe complet\remptyschedule \u0026lt;- new(FMTschedule)\r# On fait une boucle autour des diff√©rentes p√©riodes pour construire le graphe complet\rfor (period in 1:10)\r{\r# On affiche ce qui se passe dans le terminal\rprint(lpmodel$buildperiod(emptyschedule,FALSE,1)$str())\r}\r} else { # Si le mod√®le n'as pas √©t√© compil√© avec OSI, on affiche une erreur\rprint(\u0026quot;FMT needs to be compiled with OSI\u0026quot;)\r}\rL\u0026rsquo;√©quivalent en code Python est le suivant (notez qu\u0026rsquo;en Python, nous n\u0026rsquo;avons pas besoin de faire un calendrier vide pour construire le graphique complet) :\nimport sys\rfrom FMT import Models\rfrom FMT import Parser\rfrom FMT import Version\rif __name__ == \u0026quot;__main__\u0026quot;:\rif Version.FMTversion().hasfeature(\u0026quot;OSI\u0026quot;):\r# Cr√©ation de l'objet parser pour lire les fichiers de mod√®le\rnewmodelparser= Parser.FMTmodelparser()\rpath = \u0026quot;Models/TWD_Land/TWD_Land.pri\u0026quot;\rscenarios = [\u0026quot;LP\u0026quot;]\r# Lit le projet avec le parser en sp√©cifiant que l'on veut lire le sc√©nario \u0026quot;LP\u0026quot; (il peut y avoir diff√©rents sc√©narios dans un seul mod√®le)\rmodelslist = newmodelparser.readproject(path, scenarios)\r# On met le mod√®le dans le format \u0026quot;lpmodel\u0026quot; pour le mod√®le de programmation lin√©aire, en sp√©cifiant le solveur que nous voulons utiliser\rlpmodel = Models.FMTlpmodel(modelslist[0], Models.FMTsolverinterface.CLP)\r# On fait une boucle autour des diff√©rentes p√©riodes pour construire le graphe complet\rfor period in range(1, 11):\rprint(lpmodel.buildperiod())\relse:\rprint(\u0026quot;FMT needs to be compiled with OSI\u0026quot;) # Si le mod√®le n'as pas √©t√© compil√© avec OSI, on affiche une erreur\rLa sortie des deux codes devrait √™tre la suivante :\nReading Models/TWD_land/TWD_land.pri\rFMT 0.9.1, build: Sep 30 2021 12:07:49\rTue Oct 05 10:59:57 2021\rReading Scenario Lp\rFMTexc(39)Undefined _death action: _DEATH FMTsection(4)Action\rFMTexc(40)Undefined _death transition: _DEATH FMTsection(5)Transition\rDone reading Tue Oct 05 10:59:57 2021\rColumns: 58 Rows: 29 Vertices: 60 Edges: 58 Transfer Rows: 29 Output Rows: 0 Output Columns: 0\rColumns: 169 Rows: 87 Vertices: 141 Edges: 169 Transfer Rows: 87 Output Rows: 0 Output Columns: 0\rColumns: 336 Rows: 164 Vertices: 237 Edges: 336 Transfer Rows: 164 Output Rows: 0 Output Columns: 0\rColumns: 553 Rows: 259 Vertices: 350 Edges: 553 Transfer Rows: 259 Output Rows: 0 Output Columns: 0\rColumns: 805 Rows: 372 Vertices: 481 Edges: 805 Transfer Rows: 372 Output Rows: 0 Output Columns: 0\rColumns: 1088 Rows: 503 Vertices: 630 Edges: 1088 Transfer Rows: 503 Output Rows: 0 Output Columns: 0\rColumns: 1407 Rows: 652 Vertices: 797 Edges: 1407 Transfer Rows: 652 Output Rows: 0 Output Columns: 0\rColumns: 1762 Rows: 819 Vertices: 982 Edges: 1762 Transfer Rows: 819 Output Rows: 0 Output Columns: 0\rColumns: 2177 Rows: 1015 Vertices: 1196 Edges: 2177 Transfer Rows: 1015 Output Rows: 0 Output Columns: 0\rColumns: 2660 Rows: 1244 Vertices: 1443 Edges: 2660 Transfer Rows: 1244 Output Rows: 0 Output Columns: 0\rComme on peut le voir, le terminal nous montre l\u0026rsquo;√©volution des caract√©ristiques du FMTgraph au fur et √† mesure de sa construction (nombre croissant de colonnes, de liens, etc.).\nContraintes et objectif Les mod√®les de programmation lin√©aire sont accompagn√©s de contraintes et d\u0026rsquo;un objectif, pour lesquels nous voulons une solution optimis√©e.\nPar cons√©quent, pour r√©soudre un FMTlpmodel, nous devons d√©finir ces contraintes et objectifs dans le mod√®le avant de tenter de le r√©soudre.\nCes contraintes et objectifs peuvent √™tre d√©finis manuellement via les fonctions FMTlpmodel.setobjective() et FMTlpmodel.setconstraints().\nLa plupart du temps, vous allez finir par faire ce qui suit :\nR√©cup√©rer les contraintes qui sont d√©j√† dans la formulation des fichiers Woodstock du mod√®le en utilisant la fonction FMTmodel.getconstraint(). Retirer la premi√®re contrainte de la liste des contraintes que FMTmodel.getconstraint() renvoie, car la premi√®re contrainte de cette liste est en fait l\u0026rsquo;objectif du mod√®le. Ensuite, ins√©rer cet objectif et les contraintes dans le FMTlpmodel afin de le r√©soudre, en utilisant les fonctions FMTlpmodel.setobjective() et FMTlpmodel.setconstraint(). Cela donnera le code suivant, dans R :\nlibrary(FMT) # Charge FMT dans R\rif (new(FMTversion)$hasfeature(\u0026quot;OSI\u0026quot;)) # V√©rifie si FMT a √©t√© compil√© avec OSI en cr√©ant un nouvel objet FMTversion, et en utilisant la fonction hasfeature().\r{\r# Cr√©ation de l'objet parser pour lire les fichiers de mod√®le\rnewparser \u0026lt;- new(FMTmodelparser)\r# Lit le projet avec le parser en sp√©cifiant que l'on veut lire le sc√©nario \u0026quot;LP\u0026quot; (il peut y avoir diff√©rents sc√©narios dans un seul mod√®le)\rmodelslist \u0026lt;- newmodelparser$readproject(\u0026quot;Models/TWD_land/TWD_land.pri\u0026quot;, c(\u0026quot;LP\u0026quot;), TRUE, TRUE, TRUE)\r# On met le mod√®le dans le format \u0026quot;lpmodel\u0026quot; pour le mod√®le de programmation lin√©aire, en sp√©cifiant le solveur que nous voulons utiliser\rsolverinterface \u0026lt;- list(CLP=1,MOSEK=2,CPLEX=3,GUROBI=4)\rlpmodel \u0026lt;- new(FMTlpmodel,modelslist[[1]],solverinterface$MOSEK)\r# Nous cr√©ons un calendrier vide pour cr√©er le graphe complet\remptyschedule \u0026lt;- new(FMTschedule)\r# On fait une boucle autour des diff√©rentes p√©riodes pour construire le graphe complet\rfor (period in 1:10)\r{\r# On affiche ce qui se passe dans le terminal\rprint(lpmodel$buildperiod(emptyschedule,FALSE,1)$str())\r}\r# On r√©cup√®re les contraintes et objectifs\rallmodelconstraints \u0026lt;- lpmodel$getconstraints()\r# On d√©finit la premi√®re contrainte de la liste comme l'objectif du mod√®le\rmodelobjective \u0026lt;- allmodelconstraints[[1]]\r# On d√©finit toutes les autres contraintes de la liste comme les contraintes du mod√®le\rmodelconstraints \u0026lt;- allmodelconstraints[2:length(allmodelconstraints)]\r# On applique toutes les contraintes dans le mod√®le\rfor (constraint in modelconstraints)\r{\rprint(lpmodel$setconstraint(constraint)$str())\r}\r# On applique l'objectif au mod√®le\rprint(lpmodel$setobjective(modelobjective)$str())\r} else { # Si le mod√®le n'as pas √©t√© compil√© avec OSI, on affiche une erreur\rprint(\u0026quot;FMT needs to be compiled with OSI\u0026quot;)\r}\rL\u0026rsquo;√©quivalent en code Python est le suivant (remarquez qu\u0026rsquo;ici, nous allons juste \u0026ldquo;sortir\u0026rdquo; la fonction objectif de la liste des contraintes retourn√©e par FMTlpmodel.getconstraints() avec la fonction list.pop(), ce qui nous permet de boucler directement sur la liste restante pour les contraintes) :\nimport sys\rfrom FMT import Models\rfrom FMT import Parser\rfrom FMT import Version\rif __name__ == \u0026quot;__main__\u0026quot;:\rif Version.FMTversion().hasfeature(\u0026quot;OSI\u0026quot;):\r# Cr√©ation de l'objet parser pour lire les fichiers de mod√®le\rnewmodelparser= Parser.FMTmodelparser()\rpath = \u0026quot;Models/TWD_Land/TWD_Land.pri\u0026quot;\rscenarios = [\u0026quot;LP\u0026quot;]\r# Lit le projet avec le parser en sp√©cifiant que l'on veut lire le sc√©nario \u0026quot;LP\u0026quot; (il peut y avoir diff√©rents sc√©narios dans un seul mod√®le)\rmodelslist = newmodelparser.readproject(path, scenarios)\r# On met le mod√®le dans le format \u0026quot;lpmodel\u0026quot; pour le mod√®le de programmation lin√©aire, en sp√©cifiant le solveur que nous voulons utiliser\rlpmodel = Models.FMTlpmodel(modelslist[0], Models.FMTsolverinterface.CLP)\r# On fait une boucle autour des diff√©rentes p√©riodes pour construire le graphe complet\rfor period in range(1, 11):\rprint(lpmodel.buildperiod())\r# On r√©cup√®re les contraintes et objectifs\rconstraints = lpmodel.getconstraints()\r# On d√©finit la premi√®re contrainte de la liste comme l'objectif du mod√®le\robjective = constraints.pop(0)\r# On applique toutes les contraintes dans le mod√®le\rfor constraint in constraints:\rlpmodel.setconstraint(constraint)\r# On applique l'objectif au mod√®le\rlpmodel.setobjective(objective)\relse:\rprint(\u0026quot;FMT needs to be compiled with OSI\u0026quot;) # Si le mod√®le n'as pas √©t√© compil√© avec OSI, on affiche une erreur\rR√©soudre le FMTlpmodel Une fois que le graphe complet est construit, et que les contraintes et les objectifs sont fix√©s, le FMTlpmodel peut √™tre r√©solu en utilisant la fonction FMTlpmodel.initialsolve(). La fonction renvoie une valeur true ou false selon que le mod√®le a √©t√© r√©solu avec succ√®s. Si la r√©solution s\u0026rsquo;est bien pass√©e, le mod√®le conserve la solution et cette derni√®re peut √™tre interroger de diff√©rentes mani√®res (un exemple est pr√©sent√© plus bas).\nConstruire le graphe avec une solution existante (construction partielle) Parfois, on peut vouloir obtenir des r√©sultats d\u0026rsquo;une solution/planification que l\u0026rsquo;on a d√©j√† d√©j√† (voir la section suivante) sans r√©soudre le mod√®le √† nouveau, puisqu\u0026rsquo;il a d√©j√† √©t√© r√©solu pr√©c√©demment.\nDans ce cas, il est possible de lire une solution qui a √©t√© trouv√©e pr√©c√©demment, et de construire le FMTgraph du mod√®le en g√©n√©rant seulement les noeuds et les liens utilis√©s par la solution.\nPour cela, trois choses doivent √™tre faites :\nLire le fichier de calendrier du sc√©nario, et le passer √† la fonction FMTlpmodel.buildperiod(). D√©finir la solution pour chaque p√©riode avec la fonction FMTlpmodel.setsolution(). Si le mod√®le contient plusieurs actions _LOCKEXEMPT, l\u0026rsquo;utilisation de FMTlpmodel.setsolution() peut provoquer des erreurs, car les verrous ne font pas partie de la solution. Dans ce cas, vous devez utiliser la fonction FMTlpmodel.setsolutionbylp(). Cela donnera le code suivant, dans R :\nlibrary(FMT) # Charge FMT dans R\rif (new(FMTversion)$hasfeature(\u0026quot;OSI\u0026quot;)) # V√©rifie si FMT a √©t√© compil√© avec OSI en cr√©ant un nouvel objet FMTversion, et en utilisant la fonction hasfeature().\r{\r# Cr√©ation de l'objet parser pour lire les fichiers de mod√®le\rnewparser \u0026lt;- new(FMTmodelparser)\r# Indique o√π le mod√®le et la solution existante se trouvent\rprimarylocation \u0026lt;- \u0026quot;Models/TWD_land/TWD_land.pri\u0026quot;\r# On met le mod√®le dans le format \u0026quot;lpmodel\u0026quot; pour le mod√®le de programmation lin√©aire, en sp√©cifiant le solveur que nous voulons utiliser\rmodelslist \u0026lt;- newmodelparser$readproject(primarylocation, c(\u0026quot;LP\u0026quot;), TRUE, TRUE, TRUE)\r# On met le mod√®le dans le format \u0026quot;lpmodel\u0026quot; pour le mod√®le de programmation lin√©aire, en sp√©cifiant le solveur que nous voulons utiliser\rsolverinterface \u0026lt;- list(CLP=1,MOSEK=2,CPLEX=3,GUROBI=4)\rlpmodel \u0026lt;- new(FMTlpmodel,modelslist[[1]],solverinterface$MOSEK)\r# On lit le calendrier existant, qui est le premier √©l√©ment de la liste renvoy√© par la fonction\rschedules \u0026lt;- newparser$readschedules(primarylocation,modelslist)[[1]]\r# On cr√©er une variable \u0026quot;tolerance\u0026quot; qui est n√©c√©ssaire pour la fonction setsolution()\rtolerance \u0026lt;- 0.0001\r# On fait une boucle autour des p√©riodes pour construire le graphe partiel avec la solution existante\rfor (period in 1:length(schedules))\r{\rprint(lpmodel$buildperiod(schedules[[period]],TRUE,1)$str())\r}\r# On definit la solution du mod√®le √† chaque periode comme celle qui existait au depart\rfor (period in 1:length(schedules))\r{\r# On fait en sorte que le terminal nous affiche quelque chose si la solution a bien √©t√© d√©finie pour cette p√©riode\rif (lpmodel$setsolution(period, schedules[[period]], tolerance))\r{\rprint(paste(\u0026quot;Solution set at period \u0026quot;, period))\r}\r}\r} else { # Si le mod√®le n'as pas √©t√© compil√© avec OSI, on affiche une erreur\rprint(\u0026quot;FMT needs to be compiled with OSI\u0026quot;)\r}\rRemarquez qu\u0026rsquo;ici, on applique un deuxi√®me param√®tre TRUE √† lpmodel$buildperiod() pour indiquer que nous voulons forcer une construction partielle, comme indiqu√© dans la documentation de la fonction :\nRemarquez √©galement que nous avons cr√©√© une variable nomm√©e tolerance, qui est n√©cessaire √† la fonction lpmodel$setsolution(), comme l\u0026rsquo;indique la documentation une fois de plus :\nL\u0026rsquo;√©quivalent en code Python est le suivant :\nimport sys\rfrom FMT import Models\rfrom FMT import Parser\rfrom FMT import Version\rif __name__ == \u0026quot;__main__\u0026quot;:\rif Version.FMTversion().hasfeature(\u0026quot;OSI\u0026quot;):\r# Cr√©ation de l'objet parser pour lire les fichiers de mod√®le\rnewmodelparser= Parser.FMTmodelparser()\r# Indique o√π le mod√®le et la solution existante se trouvent\rpath = \u0026quot;Models/TWD_Land/TWD_Land.pri\u0026quot;\rscenarios = [\u0026quot;LP\u0026quot;]\r# On met le mod√®le dans le format \u0026quot;lpmodel\u0026quot; pour le mod√®le de programmation lin√©aire, en sp√©cifiant le solveur que nous voulons utiliser\rmodelslist = newmodelparser.readproject(path, scenarios)\r# On met le mod√®le dans le format \u0026quot;lpmodel\u0026quot; pour le mod√®le de programmation lin√©aire, en sp√©cifiant le solveur que nous voulons utiliser\rlpmodel = Models.FMTlpmodel(modelslist[0], Models.FMTsolverinterface.CLP)\r# On cr√©er une variable \u0026quot;tolerance\u0026quot; qui est n√©c√©ssaire pour la fonction setsolution()\rtolerance = 0.0001\r# On lit le calendrier existant, qui est le premier √©l√©ment de la liste renvoy√© par la fonction\rschedules = newmodelparser.readschedules(path, modellist)[0]\r# On fait une boucle autour des p√©riodes pour construire le graphe partiel avec la solution existante\rfor periodschedule in range(len(schedules)):\rprint(lpmodel.buildperiod(schedules[periodschedule], False, 1))\r# On definit la solution du mod√®le √† chaque periode comme celle qui existait au depart (on utilise +1 pour s'adapter au fait que Python commence ses listes √† 0)\rfor periodschedule in range(len(schedules)):\rlpmodel.setsolution(periodschedule+1, schedules[periodschedule], tolerance)\rprint(\u0026quot;Solution set at period\u0026quot;, periodschedule+1) else:\rprint(\u0026quot;FMT needs to be compiled with OSI\u0026quot;) # Si le mod√®le n'as pas √©t√© compil√© avec OSI, on affiche une erreur\rLa sortie des deux codes devrait √™tre la suivante :\nReading Models/TWD_land/TWD_land.pri\rFMT 0.9.1, build: Sep 30 2021 12:07:49\rTue Oct 05 10:59:57 2021\rReading Scenario Lp\rFMTexc(39)Undefined _death action: _DEATH FMTsection(4)Action\rFMTexc(40)Undefined _death transition: _DEATH FMTsection(5)Transition\rDone reading Tue Oct 05 10:59:57 2021\rColumns: 20 Rows: 10 Vertices: 28 Edges: 20 Transfer Rows: 10 Output Rows: 0 Output Columns: 0\rColumns: 40 Rows: 25 Vertices: 48 Edges: 40 Transfer Rows: 25 Output Rows: 0 Output Columns: 0\rColumns: 63 Rows: 44 Vertices: 71 Edges: 63 Transfer Rows: 44 Output Rows: 0 Output Columns: 0\rColumns: 90 Rows: 67 Vertices: 98 Edges: 90 Transfer Rows: 67 Output Rows: 0 Output Columns: 0\rColumns: 123 Rows: 95 Vertices: 131 Edges: 123 Transfer Rows: 95 Output Rows: 0 Output Columns: 0\rColumns: 157 Rows: 126 Vertices: 165 Edges: 157 Transfer Rows: 126 Output Rows: 0 Output Columns: 0\rColumns: 198 Rows: 162 Vertices: 206 Edges: 198 Transfer Rows: 162 Output Rows: 0 Output Columns: 0\rColumns: 244 Rows: 203 Vertices: 252 Edges: 244 Transfer Rows: 203 Output Rows: 0 Output Columns: 0\rColumns: 294 Rows: 248 Vertices: 301 Edges: 294 Transfer Rows: 248 Output Rows: 0 Output Columns: 0\rColumns: 351 Rows: 298 Vertices: 356 Edges: 351 Transfer Rows: 298 Output Rows: 0 Output Columns: 0\rColumns: 405 Rows: 350 Vertices: 410 Edges: 405 Transfer Rows: 350 Output Rows: 0 Output Columns: 0\rColumns: 467 Rows: 407 Vertices: 472 Edges: 467 Transfer Rows: 407 Output Rows: 0 Output Columns: 0\rColumns: 532 Rows: 468 Vertices: 537 Edges: 532 Transfer Rows: 468 Output Rows: 0 Output Columns: 0\rColumns: 599 Rows: 532 Vertices: 604 Edges: 599 Transfer Rows: 532 Output Rows: 0 Output Columns: 0\rColumns: 673 Rows: 601 Vertices: 678 Edges: 673 Transfer Rows: 601 Output Rows: 0 Output Columns: 0\rColumns: 745 Rows: 671 Vertices: 749 Edges: 745 Transfer Rows: 671 Output Rows: 0 Output Columns: 0\rColumns: 828 Rows: 747 Vertices: 831 Edges: 828 Transfer Rows: 747 Output Rows: 0 Output Columns: 0\rColumns: 912 Rows: 827 Vertices: 915 Edges: 912 Transfer Rows: 827 Output Rows: 0 Output Columns: 0\rColumns: 998 Rows: 910 Vertices: 1001 Edges: 998 Transfer Rows: 910 Output Rows: 0 Output Columns: 0\rColumns: 1091 Rows: 998 Vertices: 1094 Edges: 1091 Transfer Rows: 998 Output Rows: 0 Output Columns: 0\rSolution set at period 1\rSolution set at period 2\rSolution set at period 3\rSolution set at period 4\rSolution set at period 5\rSolution set at period 6\rSolution set at period 7\rSolution set at period 8\rSolution set at period 9\rSolution set at period 10\rSolution set at period 11\rSolution set at period 12\rSolution set at period 13\rSolution set at period 14\rSolution set at period 15\rSolution set at period 16\rSolution set at period 17\rSolution set at period 18\rSolution set at period 19\rSolution set at period 20\rObtenir des valeurs de sortie du mod√®le Il existe plusieurs fa√ßons de lire les diff√©rentes sorties du mod√®le.\nEn R, il existe une fonction particuli√®re (seulement disponible en R) appel√©e getoutsdataframe() ; mais pour R, Python et C++, il est possible d\u0026rsquo;utiliser la fonction FMTmodel.getoutputs() pour obtenir une liste des sorties (outputs) disponibles pour un mod√®le donn√©.\nIl est possible de s√©lectionner un FMToutputlevel diff√©rent afin d\u0026rsquo;obtenir une sortie √† diff√©rentes √©chelles dans le mod√®le.\nPour un exemple, voir exercice 1.\nExportation du calendrier d\u0026rsquo;un mod√®le r√©solu L\u0026rsquo;exportation du calendrier d\u0026rsquo;un mod√®le r√©solu se fait via l\u0026rsquo;objet FMTscheduleparser que nous avons utilis√© lors de la construction du graphe partiel (voir sections pr√©c√©dentes).\nLa solution d\u0026rsquo;un mod√®le peut √™tre mise dans une liste en utilisant la fonction FMTlpmodel.getsolution() pour chacune des p√©riodes d\u0026rsquo;int√©r√™t.\nEnsuite, la liste des solutions pour chaque p√©riode doit √™tre transform√©e en un vecteur, qui peut ensuite √™tre √©crit dans un fichier .txt en utilisant la fonction FMTscheduleparser.write().\nPour un exemple, voir exercice 1.\nPr√©solution d\u0026rsquo;un mod√®le Certains mod√®les peuvent √™tre difficiles √† r√©soudre, √† cause de leur nombre √©lev√© d\u0026rsquo;actions, de strates, et ainsi de suite.\nDans ce cas, la fonction FMTmodel.basepresolve() peut √™tre utilis√©e pour pr√©solutioner le mod√®le.\nCette fonction retourne un mod√®le avec moins de th√®mes, d\u0026rsquo;actions, de transitions, de sorties et de contraintes que le mod√®le original, mais avec la m√™me quantit√© d\u0026rsquo;informations. Cela le rend plus facile √† r√©soudre, tout en donnant la m√™me r√©ponse √† la fin.\nDans certaines situations, FMT pr√©solutionerra le mod√®le automatiquement.\nMaintenant que vous savez tout ce qu\u0026rsquo;il y a √† savoir sur l\u0026rsquo;optimisation √† spatialement r√©f√©renc√©e dans FMT, nous vous recommandons d\u0026rsquo;essayer l\u0026rsquo;exercice 1 pour vous aider √† apprendre √† utiliser FMT en pratique. Dans cet exercice, vous apprendrez √† utiliser par vous-m√™me certaines des fonctions les plus r√©guli√®rement utilis√©es.\n","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"fr","lastmod":1557010800,"objectID":"1944b4f83faa7919c3330c50fbf3bbde","permalink":"https://bureau-du-forestier-en-chef.github.io/FMTdocs/fr/docs/basics/spatially_referenced_optimization/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/FMTdocs/fr/docs/basics/spatially_referenced_optimization/","section":"docs","summary":"Dans la section pr√©c√©dente, nous avons vu comment lire un mod√®le Woodstock et le charger dans un objet FMTlpmodel.\nFMTlpmodel vous permettra de r√©soudre un mod√®le de programmation lin√©aire √† spatialement r√©f√©renc√©, ce qui vous donnera un calendrier (schedule) optimis√© d\u0026rsquo;op√©rations foresti√®res en fonction d\u0026rsquo;un objectif et d\u0026rsquo;un ensemble de contraintes.","tags":null,"title":"Optimisation spatiallement r√©f√©renc√©e","type":"book"},{"authors":null,"categories":null,"content":"Les COS et la planification spatiale des coupes Un COS (Compartiment d\u0026rsquo;Organisation Spatiale) est une aire de for√™t que l\u0026rsquo;on peut utiliser pour agr√©ger des zones de coupes foresti√®res dans l\u0026rsquo;espace. Dans Woodstock, elle est repr√©sent√©e de mani√®re spatialement r√©f√©renc√©e par un groupe d\u0026rsquo;aires ou des peuplements qui partagent un num√©ro de COS commun.\nL\u0026rsquo;agr√©gation des coupes foresti√®res a √©t√© pendant un temps vue d\u0026rsquo;un mauvais ≈ìil dans certains pays √† cause des vastes √©tendues de for√™ts coup√©es continues qu\u0026rsquo;elle pouvait g√©n√©rer. Cependant, elle est aujourd\u0026rsquo;hui consid√©r√©e √† nouveau dans le but de minimiser l\u0026rsquo;√©tendue des zones de coupes au niveau du paysage, ainsi que la quantit√© de chemins forestiers g√©n√©r√©s. Le prix des coupes en est √©galement r√©duit par une r√©duction des d√©placements et de la complexit√© lors des interventions foresti√®res.\nFMT propose ainsi diff√©rentes fonctions qui permettent de d√©river un calendrier d\u0026rsquo;ouverture et de fermeture de COS qui respecte plusieurs contraintes spatiales donn√©es quant √† la taille des zones de coupes. Ainsi, le calendrier va fermer des COS trop proches lorsque cela pourrait causer des tailles de coupes trop grandes si elles √©taient choisies, ou bien forcer de grandes coupes en restreignant les COS disponibles pour la coupe.\nCe calendrier d\u0026rsquo;ouverture et de fermeture de COS va ainsi permettre de communiquer les contraintes spatiales aux mod√®les de programmation lin√©aire bas√©s sur des fichiers Woodstock que FMT utilise (voir les bases de FMT). FMT va alors pouvoir g√©n√©rer une nouvelle solution pour un mod√®le avec l\u0026rsquo;ajout de ce calendrier. Bien √©videmment, lorsque l\u0026rsquo;on ajoute des contraintes additionnelles au mod√®le, cela a g√©n√©ralement pour cause de r√©duire la quantit√© de bois qui est r√©coltable dans la solution optimale. Ainsi, l\u0026rsquo;ajout de ce calendrier d\u0026rsquo;ouvertures et de fermetures de COS va r√©duire le bois r√©colt√© dans la nouvelle solution g√©n√©r√©e par FMT.\nL\u0026rsquo;id√©e est alors de trouver un calendrier \u0026ldquo;optimal\u0026rdquo; qui va r√©duire le moins possible la quantit√© de bois r√©coltable dans la solution du mod√®le. On peut le faire par le biais du processus it√©ratif suivant :\nOn calcule la solution du mod√®le sans calendrier. On g√©n√®re un premier calendrier d\u0026rsquo;ouverture et de fermeture de COS qui respecte les contraintes spatiales donn√©es. Ce calendrier est simplement \u0026ldquo;r√©alisable\u0026rdquo;; il n\u0026rsquo;est pas forc√©ment optimis√©, mais respecte simplement toutes les contraintes. On ajoute le calendrier au mod√®le, et on recalcule la solution du mod√®le. On compare la quantit√© de bois r√©colt√© dans la premi√®re solution (sans calendrier) avec cette nouvelle solution (avec calendrier). On obtient le % de r√©duction de bois r√©coltable dont le calendrier est responsable. Le but est alors d\u0026rsquo;optimiser le calendrier pour r√©duire ce pourcentage autant que possible. On r√©alise ensuite la boucle suivante (appell√©e un greedy algorithm) avec autant d\u0026rsquo;it√©rations que n√©cessaire : On change le calendrier des COS de mani√®re al√©atoire tout en faisant en sorte qu\u0026rsquo;il continue de respecter toutes les contraintes spatiales On ins√®re le calendrier dans le mod√®le et l\u0026rsquo;on recalcule la solution Si le calendrier a r√©duit le pourcentage de r√©duction de bois r√©coltable, on garde la modification al√©atoire pour l\u0026rsquo;it√©ration suivante Sinon, on annule cette modification al√©atoire et l\u0026rsquo;on en cherche une autre Il est possible de r√©soudre le probl√®me de l\u0026rsquo;optimisation du calendrier avec des m√©thodes plus complexes, comme celle du mixed integer programming (MIP) pour obtenir une solution vraiment optimale. Cependant, ces algorithmes peuvent demander beaucoup trop de calcul pour des mod√®les de programmation lin√©aire qui concernent des paysages forestiers complexes. Dans ce cas-l√†, le greedy algorithm est utile pour √©viter des temps de calcul trop longs. L\u0026rsquo;impl√©mentation des COS dans des fichiers Woodstock La syntaxe des fichiers Woodstock n\u0026rsquo;est pas faite pour permettre de l\u0026rsquo;optimisation via des contraintes spatiales. Cependant, le syst√®me des COS utilis√© par FMT peut √™tre mis en place dans des fichiers Woodstock par le biais d\u0026rsquo;un yield.\nPar exemple, il est possible de cr√©er un yield nomm√© youvert qui d√©crit si un peuplement est disponible √† la r√©colte ou non. Ce yield peut alors √™tre assign√© √† un num√©ro de COS pr√©sent dans un th√®me, et va donc s\u0026rsquo;appliquer √† tous les peuplements qui sont associ√©s √† ce num√©ro de COS via ce m√™me th√®me. Il peut ensuite servir √† restreindre certaines actions (e.g., des coupes) au sein du mod√®le.\nDans la section YIELD du mod√®le woodstock, ce yield qui indique quand un COS est ouvert ou ferm√© aura une valeur pour chacune des p√©riodes du mod√®le. Cet enchainement de valeurs repr√©sente donc le calendrier d\u0026rsquo;ouverture ou de fermeture des COS. En pratique, la section YIELD qui contient le calendrier formul√© par FMT prendra la forme suivante (ici, le yield youvert indique si un COS est ouvert ou ferm√©) :\nPour ce qui est d\u0026rsquo;une action dans le mod√®le comme une coupe, le yield peut √™tre utilis√© de la mani√®re suivante dans la section ACTION du mod√®le pour restreindre l\u0026rsquo;action √† des COS ouverts :\nFonctions utilis√©es et param√®tres n√©cessaires FMT propose plusieurs fonctions qui permettent de cr√©er un calendrier optimis√© d\u0026rsquo;ouverture et de fermeture de COS dans FMT. Ces fonctions n√©cessitent diff√©rents param√®tres qui seront d√©crits ici.\nCette documentation ne traitera pas du probl√®me de la d√©finition des COS, que l\u0026rsquo;on appelle le clustering. Id√©alement, d√©finir les COS (c.-√†-d. attribuer des num√©ros de COS a des peuplements) devrait se faire en m√™me temps qu\u0026rsquo;optimiser le calendrier; mais cela repr√©sente une op√©ration tr√®s complexe. Ainsi, le clustering est g√©n√©ralement fait en amont de l\u0026rsquo;optimisation du calendrier, en regroupant des strates similaires et proches dans l\u0026rsquo;espace.\nAinsi, pour pouvoir utiliser les fonctions suivantes, les COS doivent d√©j√† avoir √©t√© ins√©r√©s dans les fichiers du mod√®le sous forme de num√©ros de COS associ√©s aux peuplements par des masques. Voir la section pr√©c√©dente pour plus d\u0026rsquo;information.\nCr√©ation des COS au sein d\u0026rsquo;un mod√®le de programmation lin√©aire dans FMT Dans FMT, une fois qu\u0026rsquo;un mod√®le lin√©aire a √©t√© cr√©√© en se basant sur des fichiers woodstock (voir les bases de FMT), il est possible de cr√©er la structure des COS au sein du mod√®le (voir sections pr√©c√©dentes) par le biais de la fonction Heuristics.FMToperatingareascheme().\nLa fonction Heuristics.FMToperatingareascheme() sert √† construire un seul COS au sein du mod√®le, et doit donc √™tre r√©p√©t√©e pour chacun des COS qui doit √™tre cr√©√©. Elle n√©cessite diff√©rents param√®tres. Ces param√®tres servent √† donner des contraintes sur comment et quand un COS peut √™tre ouvert dans le calendrier.\nVous trouverez un exemple de cette cr√©ation dans la section suivante.\nLe calendrier d\u0026rsquo;ouverture et de fermeture des COS que FMT pourra cr√©er par la suite est tr√®s sensible √† ces diff√©rents param√®tres. Si ceux-ci sont mal indiqu√©s, FMT pourrait √™tre incapable de trouver une solution r√©alisable au mod√®le. Le premier param√®tre contient le COS √† cr√©er en soi. Celui-ci peut √™tre construit √† l\u0026rsquo;aide de la fonction Heuristics.FMToperatingarea(), qui prend elle-m√™me deux param√®tres : le premier est le masque qui va d√©crire quels peuplements seront contenus dans ce COS, et le second est le neihgbors perimeter, ou p√©rim√®tre des voisins. Ce second param√®tre d√©crit le ratio du p√©rim√®tre du COS que celui-ci doit avoir en commun avec un autre COS pour que les deux soient consid√©r√©s comme voisins. Par exemple, si le p√©rim√®tre des voisins est de 0.5, alors 50% du p√©rim√®tre du COS doit √™tre partag√© avec un autre COS pour qu\u0026rsquo;ils soient consid√©r√©s comme voisins. Le deuxi√®me param√®tre est le opening time, ou le temps d\u0026rsquo;ouverture. Il d√©finit combien de temps le COS doit rester ouvert lorsqu\u0026rsquo;il est ouvert sur une p√©riode. Par exemple, si le temps d\u0026rsquo;ouverture est de 5, alors le COS sera toujours ouvert pour 5 p√©riodes √† la fois. Le troisi√®me param√®tre est le return time, ou temps de retour. Il correspond au nombre de p√©riodes de temps qui doivent √™tre respect√©s avant que le COS soit r√©ouvert dans le futur. Par exemple, si le temps de retour est de 5, alors il doit y avoir au moins 5 p√©riodes de temps entre deux ouvertures du COS. Le quatri√®me param√®tre est le repetition pattern, ou la r√©p√©tition du patron de r√©colte. Il est sup√©rieur ou √©gal √† 1, et il va effectivement forcer le COS √† suivre plusieurs fois un patron d\u0026rsquo;ouvertures/fermetures dans le temps qui correspond √† une alternance entre son temps d\u0026rsquo;ouverture et de fermeture. Par exemple, pour un temps d\u0026rsquo;ouverture de 2, un temps de fermeture de 3 et une valeur de r√©p√©tition du patron de r√©colte de 2, une fois le COS ouvert, il suivra automatiquement le calendrier \u0026ldquo;ouvert, ouvert, ferm√©, ferm√©, ferm√©, ouvert, ouvert, ferm√©, ferm√©, ferm√©\u0026rdquo;, ce qui correspondant √† 2 r√©p√©titions de ses param√®tres d\u0026rsquo;ouverture et de fermeture. Le cinqui√®me param√®tre est la green up period, ou p√©riode de verdissement. Elle correspond au d√©lai que doit attendre le COS pour √™tre ouvert √† nouveau si un COS voisin est r√©colt√©. Les COS voisins sont en retour trouv√©s gr√¢ce au p√©rim√®tre des voisins donn√© plus t√¥t. Le sixi√®me param√®tre est la starting period, ou p√©riode de d√©part. Elle correspond √† la p√©riode √† partir de laquelle le COS peut commencer √† √™tre ouvert dans le mod√®le. Tous les COS cr√©√©s par la fonction Heuristics.FMToperatingareascheme() doivent id√©alement √™tre mis au sein d\u0026rsquo;une liste, qui sera donn√©e en param√®tre √† une autre fonction par la suite.\nD√©termination des COS voisins pour utiliser des contraintes spatiales avanc√©es Il est possible que vous ayez un fichier shapefile contenant la position dans l\u0026rsquo;espace de chacun des COS.\nSi c\u0026rsquo;est le cas, il est alors possible de d√©terminer quels COS sont voisins en lisant le fichier shapefile, et en comparant les num√©ros des polygones correspondant aux COS dans ce fichier shapefile avec ceux qui se trouvent dans les fichiers du mod√®le lin√©aire. Cela permet d\u0026rsquo;utiliser la contrainte spatiale d√©termin√©e par le param√®tre green up period d√©crit dans la section pr√©c√©dente.\nPour utiliser les fonctions suivantes, les premiers attributs pr√©sents dans le fichier shapefile/vectoriel doivent correspondre aux th√®mes pr√©sents dans les fichiers Woodstock de votre mod√®le.\nLe fichier shapefile ou vectoriel peut contenir d\u0026rsquo;autres attributs par la suite; mais sans ces premiers attributs correspondants aux th√®mes des fichiers Woodstock, les fonctions de FMT ne pourront pas reconnaitre quel polygone correspond √† quel COS, et elles ne fonctionneront pas.\nPour cela, il est possible d\u0026rsquo;utiliser la fonction getschemeneighbors() d\u0026rsquo;un objet FMTareaparser cr√©√© auparavant, et de lui fournir la liste de COS cr√©e par le biais de Heuristics.FMToperatingareascheme() (voir section pr√©c√©dente) ainsi que le fichier shapefile (ou un autre type de fichier vectoriel) qui contient les COS. Il suffit ensuite d\u0026rsquo;indiquer quels sont les champs du fichier shapefile qui contiennent les informations li√©es √† l\u0026rsquo;√¢ge des COS et leur aire. Il est possible d\u0026rsquo;utiliser des param√®tres optionnels afin de ne pas consid√©rer les COS avec des aires trop petites.\nEn se faisant, la fonction getschemeneighbors() renverra une liste de COS similaire √† celle cr√©√©e par Heuristics.FMToperatingareascheme(); cependant, pour chacun des COS, le vecteur indiquant la liste de leurs voisins spatiaux sera rempli.\nCela devrait prendre la forme suivante :\n# On cr√©er l'objet FMTareaparser\rareap = Parser.FMTareaparser()\r# On indique le chemin du fichier shapefile\rshapefileLocation = \u0026quot;./spatialCompartments.shp\u0026quot;\r# On utilise la fonction sur une liste de COS deja cr√©e avec Heuristics.FMToperatingareascheme() auparavant, operaeas\r# L'objet \u0026quot;modelthemes\u0026quot; contient les themes du mod√®le\r# La liste sera mise a jour avec des COS qui contiennent leur vecteur de voisins remplis selon leur position dans l'espace d√©crite dans le fichier vectoriel spatialCompartments.shp donn√© en argument\ropeareas = areap.getschemeneighbors(opeareas,modelthemes,shapefileLocation,\u0026quot;AGE\u0026quot;,\u0026quot;SUPERFICIE\u0026quot;)\rPour plus d\u0026rsquo;informations, voir la page doxygen de FMTareaparser et la section sur getschemeneighbors\nCr√©ation d\u0026rsquo;un output node li√© aux actions influenc√©es par le calendrier des COS. Afin de pouvoir commencer √† optimiser le calendrier des COS (voir section suivante), il faut fournir √† FMT diff√©rentes informations quand aux actions et aux peuplements qui seront affect√©s par les COS. Pour ce faire, FMT a besoin des FMToutputnode li√©s aux actions qui seront vis√©es par les ouvertures et fermeture de COS (par exemple, un type de coupes qui ne peuvent pas se faire trop proches les une des autres). Ces objets sont seulement utilis√©s parce qu\u0026rsquo;ils sont les plus utiles pour cette √©tape, et non pas parce qu\u0026rsquo;ils sont les seuls qui peuvent donner ces informations √† FMT.\nLes objets FMToutputnode contiennent les output nodes du mod√®le lin√©aire. Ces derniers sont compos√©s de 4 √©l√©ments : un masque (pour d√©finir les peuplements consid√©r√©s par l\u0026rsquo;output node), une action, un yield, et un param√®tre qui peut √™tre utilis√© pour modifier le yield. Par exemple, un output node peut concerner 80% du volume brut r√©colt√© par les coupes totales dans tous les peuplements via la mention ? ? ? coupetotale volumebrut * 0.88. Les output nodes sont indiqu√©s dans le fichier .out de la formulation Woodstock. Plusieurs output nodes peuvent alors √™tre combin√© pour donner un seul output.\nAfin de fournir ces FMToutputnode √† FMT, deux m√©thodes sont disponibles :\nIl est possible de cr√©er un nouvel objet FMToutputnode qui contiendra toutes les actions vis√©es par les COS en faisant un agr√©gat de ces actions. Pour ce faire, il suffit d\u0026rsquo;indiquer un nom d\u0026rsquo;agr√©gat d\u0026rsquo;action √† toutes les actions vis√©es via la fonction push_aggregate() associ√©es aux objets FMTaction; puis, √† fournir ce nom d\u0026rsquo;agr√©gats au constructeur de FMToutputnode. Si ces actions concernent tous les peuplements possibles, le constructeur poura alors prendre la forme FMToutputnode(Core.FMTmask((\u0026quot;? \u0026quot;*len(themes))[:-1],themes),Agg_name), avec Agg_name contenant le nom de l\u0026rsquo;agr√©gat des actions vis√©es par les COS. Il est aussi possible de r√©cup√©rer un FMToutputnode qui est contenu dans l\u0026rsquo;un des FMToutput du mod√®le directement via la fonction getnodes() associ√©e aux objets FMToutput. Un exemple de la deuxi√®me m√©thode est montr√© dans l\u0026rsquo;exemple de script plus bas.\nLancement du greedy algorithm et r√©cup√©ration du calendrier optimis√© La derni√®re √©tape est de lancer le greedy algorithm pour cr√©er un calendrier optimis√©.\nPour ce faire, il suffit de cr√©er un objet qui va contenir la \u0026ldquo;t√¢che\u0026rdquo; du greedy algorithm, et de donner cette t√¢che √† une fonction de FMT qui s\u0026rsquo;occupe de lancer les t√¢ches parall√®les. Ces deux √©tapes sont essentielles, car le greedy algorithm de FMT utilise des t√¢ches en parall√®le afin de r√©aliser les diff√©rentes it√©rations de l\u0026rsquo;algorithme aussi rapidement que possible.\nLa cr√©ation de l\u0026rsquo;objet contenant la t√¢che de l\u0026rsquo;algorithme se fait via la fonction Parallel.FMTopareaschedulertask(). La fonction n√©cessite 7 param√®tres :\nLe FMTlpmodel qui contient le mod√®le lin√©aire pour lequel on veut faire le calendrier des COS Un objet contenant la liste de COS (voir la section pr√©c√©dente) Le output node cr√©√© dans la section pr√©c√©dente Une chaine de caract√®res (string) qui indique o√π les fichiers cr√©√©s par la fonction (qui contiennent des informations sur le calendrier optimis√© final) seront copi√©s Une chaine de caract√®res (string) indiquant le nom de l\u0026rsquo;output li√© au statut ouvert ou ferm√© des COS (par exemple youvert; voir sections pr√©c√©dentes) Un nombre indiquant le nombre maximum d\u0026rsquo;it√©rations que le greedy algorithm peut r√©aliser avant de s\u0026rsquo;arr√™ter (voir sections pr√©c√©dentes) Un nombre indiquant le temps maximal (en secondes) que le greedy algorithm peut prendre avant de s\u0026rsquo;arr√™ter; l\u0026rsquo;algorithme s\u0026rsquo;arrettera si ce temps ou si le nombre d\u0026rsquo;it√©rations maximal est atteint Une fois que l\u0026rsquo;objet contenant la t√¢che est cr√©√© avec cette fonction, il doit √™tre pass√© √† la fonction Parallel.FMTtaskhandler(). Cette fonction peut accepter un second param√®tre qui indique le nombre de c≈ìurs du processeur de l\u0026rsquo;ordinateur que la fonction utilisera pour r√©aliser les op√©rations en parall√®le. La fonction retournera un objet FMTtaskhandler, qui peut ensuite lancer l\u0026rsquo;algorithme pour de bon √† l\u0026rsquo;aide de la fonction conccurentrun() de l\u0026rsquo;objet.\nIl est aussi possible de ne pas lancer le greedy algorithm, mais d\u0026rsquo;obtenir un premier calendrier non optimis√©, mais simplement \u0026ldquo;r√©alisable\u0026rdquo;. Pour cela, il suffit d\u0026rsquo;utiliser la fonction getoperatingareaschedulerheuristics() d\u0026rsquo;un objet FMTlpmodel en lui fournissant un objet contenant la liste des COS et un output node, ainsi que le nombre de calendriers non optimis√©s que l\u0026rsquo;on veut obtenir. Un exemple est montr√© dans ce script aux lignes 34-35.\nExemple de script Un exemple de script tr√®s simple pour cr√©er un calendrier de COS non optimis√© en python est disponible √† cette adresse. Ce script ne fait que g√©n√©rer une premi√®re version non optimis√©e d\u0026rsquo;un calendrier pour les COS, mais qui est simplement r√©alisable en fonction des contraintes donn√©es.\nLe script suivant est une autre version de ce script qui est int√©gralement comment√©, et qui lance √† la fin le greedy algorithm pour obtenir un calendrier optimis√© de COS.\n# Ici, on charge FMT directement, comme s'il avait √©t√© install√© avec pip.\rfrom FMT import Models\rfrom FMT import Parser\rfrom FMT import Core\rfrom FMT import Heuristics\rfrom FMT import Version if __name__ == \u0026quot;__main__\u0026quot;:\r# On v√©rifie que FMT poss√®de bien les fonctions n√©cessaires pour ce script\rif Version.FMTversion().hasfeature(\u0026quot;OSI\u0026quot;):\r# Definition du chemin menant au mod√®le woodstock\rprimarylocation = \u0026quot;../Models/TWD_land/TWD_land.pri\u0026quot;\r# Cr√©ation d'un objet pour lire le mod√®le (parser)\rmodelparser = Parser.FMTmodelparser()\r# On lit le model gr√¢ce au parser.\rmodels = modelparser.readproject(primarylocation,[\u0026quot;LP\u0026quot;])\r# On d√©sactive le log pour ce mod√®le (optionel)\rmodels[0].setquietlogger()\r# On charge le mod√®le parmis la liste des mod√®les renvoy√©s\roptimizationmodel=Models.FMTlpmodel(models[0],Models.FMTsolverinterface.CLP)\r# On r√©cup√®re les th√®mes du mod√®le\rthemes = optimizationmodel.getthemes()\r# On cr√©√© une liste que l'on va remplir avec les op√©ratings areas\ropareas = []\r# Pour chacun des num√©ros de COS pr√©sent dans les th√®mes, on cr√©er une COS que l'on met dans la liste\rfor attribute in themes[2].getattributes(\u0026quot;?\u0026quot;):\rmask = [\u0026quot;?\u0026quot; for theme in themes]\rmask[2] = attribute\r# On cr√©er le COS avec le masque qui s√©lectionne les peuplements avec les num√©ros de COS\r# On utilise un opening time de 2, un return time de 1, une reptition de 4, une green up period de 0, et une starting period de 1.\ropareas.append(Heuristics.FMToperatingareascheme(Heuristics.FMToperatingarea(Core.FMTmask(mask,themes),0),2,1,4,0,1))\r# Les lignes suivantes vont trouver une solution initiale au mod√®le, sans calendrier de COS. Voir bases de FMT.\rfor period in range(0,10):\rprint(optimizationmodel.buildperiod())\rallconstraints = optimizationmodel.getconstraints()\robjective = allconstraints.pop(0)\rfor constraint in allconstraints:\roptimizationmodel.setconstraint(constraint)\roptimizationmodel.setobjective(objective)\roptimizationmodel.initialsolve()\r# On r√©cup√®re les output nodes du mod√®le n√©cessaires pour cr√©er un calendrier de COS grace aux actions qu'ils contiennent\rnodeofoutput = None\rfor output in optimizationmodel.getoutputs():\rif \u0026quot;OSUPREC\u0026quot; == output.getname():\rnodeofoutput = output.getnodes(optimizationmodel.getarea(),optimizationmodel.getactions(),optimizationmodel.getyields())[0]\rbreak;\r# On finit en d√©finissant les param√®tres n√©cessaires pour lancer le greedy algorithm : l'endroit ou mettre les outputs, et le temps maximal et le nombre d'it√©rations maximales pour l'algorithme.\routputsLocation = \u0026quot;./Outputs/outputCalendrier\u0026quot;\rmaximumIterations = 30\rmaximumTime = 1209600 # Temps maximum en seconde; ici, cela correspond √† deux semaines.\r# On cr√©er l'objet qui contient la t√¢che √† lancer avec le greedy algorithm\rmaintask = Parallel.FMTopareaschedulertask(optimizationmodel, opeareas, outputsLocation, \u0026quot;YOUVERT\u0026quot;, maximumIterations, maximumTime)\r# On met la t√¢che au sein d'un objet qui g√®re le lancement des t√¢ches en parall√®le dans FMT\rhandler = Parallel.FMTtaskhandler(maintask,self.thr)\r# On active l'enregistrement du log de la t√¢che\rhandler.settasklogger()\r# on lance la t√¢che du greedy algorithm en parral√®le\rhandler.conccurentrun()\relse:\rprint(\u0026quot;FMT needs to be compiled with OSI\u0026quot;)\r","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"fr","lastmod":1557010800,"objectID":"ccad905f191f54fdede3399dde3d8dae","permalink":"https://bureau-du-forestier-en-chef.github.io/FMTdocs/fr/docs/advanced/operational_area_scheduling/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/FMTdocs/fr/docs/advanced/operational_area_scheduling/","section":"docs","summary":"Les COS et la planification spatiale des coupes Un COS (Compartiment d\u0026rsquo;Organisation Spatiale) est une aire de for√™t que l\u0026rsquo;on peut utiliser pour agr√©ger des zones de coupes foresti√®res dans l\u0026rsquo;espace.","tags":null,"title":"Planification des Compartiments d'Organisation Spatiale (COS)","type":"book"},{"authors":null,"categories":null,"content":" Si git n\u0026rsquo;est pas install√© sur votre ordinateur, installez-le depuis ce lien. Git est un logiciel libre et gratuit utilis√© pour aider √† organiser la fa√ßon dont les gens cr√©ent le code source de programmes ou d\u0026rsquo;outils, et comment ils collaborent pour le faire.\nIci, git vous aidera √† t√©l√©charger le code utilis√© pour faire fonctionner le logiciel vcpkg, qui t√©l√©chargera toutes les librairies dont FMT a besoin pour le compiler.\nUtilisez git clone https://github.com/microsoft/vcpkg.git dans l\u0026rsquo;invite de commande pour t√©l√©charger vcpkg. Si vous avez ferm√© l\u0026rsquo;invite de commande, ou si vous ne vous souvenez pas comment l\u0026rsquo;ouvrir, consultez la page pr√©c√©dente. Utilisez cd ./vcpkg dans l\u0026rsquo;invite de commande pour naviguer dans le dossier vcpkg. Si vous ne vous souvenez pas comment utiliser cd, consultez la page pr√©c√©dente. Copiez/collez la commande suivante dans l\u0026rsquo;invite de commande pour installer les d√©pendances et librairies n√©cessaires √† la compilation de FMT grace √† vcpkg : vcpkg install boost:x64-windows boost-dll:x64-windows boost-icl:x64-windows boost-python:x64-windows gdal:x64-windows geos:x64-windows pthreads:x64-windows clp:x64-windows\rCela prendra du temps, et utilisera un certain espace sur votre ordinateur (environ 10 Go).\nLaissez juste l\u0026rsquo;invite de commande ouverte pour que vcpkg fasse son travail.\nUne fois que vcpkg est termin√©, passez √† la page suivante.\n","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"fr","lastmod":1557010800,"objectID":"bfc7fa201cc9979fa31631fd6f787541","permalink":"https://bureau-du-forestier-en-chef.github.io/FMTdocs/fr/docs/download_install/downloading_libraries/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/FMTdocs/fr/docs/download_install/downloading_libraries/","section":"docs","summary":"Si git n\u0026rsquo;est pas install√© sur votre ordinateur, installez-le depuis ce lien. Git est un logiciel libre et gratuit utilis√© pour aider √† organiser la fa√ßon dont les gens cr√©ent le code source de programmes ou d\u0026rsquo;outils, et comment ils collaborent pour le faire.","tags":null,"title":"T√©l√©charger les librairies","type":"book"},{"authors":null,"categories":null,"content":"Maintenant que tout est pr√™t, il est temps de passer √† l\u0026rsquo;√©tape de compilation proprement dite.\nUtilisez cd .. pour retourner dans le dossier FMT-Installation.\nClonez le repository de FMT en utilisant git clone https://github.com/Bureau-du-Forestier-en-chef/FMT.git.\nUtilisez cd ./FMT pour naviguer dans le dossier FMT t√©l√©charg√© depuis le repository de FMT.\nCopiez/collez les commandes suivantes dans le bloc-notes de Windows, puis remplacez le param√®tre -DMOSEK_DIR par l\u0026rsquo;emplacement de Mosek sur votre ordinateur :\ncmake CMakeLists.txt -B build/release -G \u0026quot;Visual Studio 16 2019\u0026quot; -DBUILD_TYPE=Release -DVCPKG_TARGET_TRIPLET=x64-windows -DCMAKE_TOOLCHAIN_FILE=\u0026quot;../vcpkg/scripts/buildsystems/vcpkg.cmake\u0026quot; -DBOOST_DIR=\u0026quot;../vcpkg/installed/x64-windows/\u0026quot; -DCMAKE_BUILD_TYPE=Release -DGDAL_DIR=\u0026quot;../vcpkg/installed/x64-windows/\u0026quot; -DGEOS_DIR=\u0026quot;../vcpkg/installed/x64-windows/\u0026quot; -DOSI_DIR=\u0026quot;../vcpkg/installed/x64-windows/\u0026quot; -DPYTHON_DIR=\u0026quot;../vcpkg/packages/python3_x64-windows/\u0026quot; -DMOSEK_DIR=\u0026quot;C:/PROGRA~1/Mosek/\u0026quot;\rcmake --build build/release --config Release\rcmake --install build/release --config Release\rPar d√©faut, Mosek est install√© dans votre dossier C:/Program Files sous Windows. Ceci peut √™tre exprim√© par le chemin C:/PROGRA~1 pour √©viter l\u0026rsquo;espace entre Program et Files, qui peut cr√©er des erreurs.\nAinsi, si vous avez install√© Mosek dans C:\\Program Files\\Mosek, vous pouvez conserver C:/PROGRA~1/Mosek/ dans ces commandes.\nSi vous avez install√© une version ant√©rieure de Visual Studio √† celle de 2019, il vous faudra changer la partie indiquant la version de Visual Studio. Copiez/collez toutes les commandes qui sont pr√™tes dans le bloc-notes vers l\u0026rsquo;invite de commande pour lancer la compilation. Appuyez sur la touche Entr√©e pour les activer. Cela prendra du temps, et vous pourriez voir des avertissements dans l\u0026rsquo;invite de commande pendant le processus. Ne vous en inqui√©tez pas. Si la compilation se termine par des messages d\u0026rsquo;erreur en rouge, vous pouvez poster un probl√®me sur la page des probl√®mes du repository de FMT. Si tout a fonctionn√©, f√©licitations ! Il ne nous reste plus qu\u0026rsquo;√† importer FMT dans Python et √† v√©rifier que tout fonctionne.\n","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"fr","lastmod":1557010800,"objectID":"28b33694d2653cd0b0dcc16d3adf2fb2","permalink":"https://bureau-du-forestier-en-chef.github.io/FMTdocs/fr/docs/download_install/compiling/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/FMTdocs/fr/docs/download_install/compiling/","section":"docs","summary":"Maintenant que tout est pr√™t, il est temps de passer √† l\u0026rsquo;√©tape de compilation proprement dite.\nUtilisez cd .. pour retourner dans le dossier FMT-Installation.\nClonez le repository de FMT en utilisant git clone https://github.","tags":null,"title":"Compiler","type":"book"},{"authors":null,"categories":null,"content":"Dans cet exercice, vous allez essayer d\u0026rsquo;utiliser FMT pour lire un sc√©nario, le r√©soudre, lire une de ses sorties, et exporter la solution.\nPour faire cet exercice, vous devez avoir install√© FMT sur votre ordinateur et avoir t√©l√©charg√© les fichiers d\u0026rsquo;exemples depuis le d√©p√¥t GitHub de FMT.\nüíæ T√©l√©charger et installer FMT üíæ T√©l√©charger les fichiers d\u0026rsquo;exemples de FMT Objectifs de l\u0026rsquo;exercice Utilisez FMT pour :\nLire le mod√®le Woodstock TWD_land dans les fichiers d\u0026rsquo;exemples en s√©lectionnant son sc√©nario nomm√© LP. N\u0026rsquo;oubliez pas de s√©lectionner le solveur CLP lors de la lecture du mod√®le. R√©solvez le mod√®le en Construisant son graphe complet pour 10 p√©riodes D√©finissant l\u0026rsquo;objectif et les contraintes du mod√®le Utilisant la fonction FMTmodel.initialsolve() pour le r√©soudre. Lire les valeurs de la sortie OSUPREC du mod√®le en Obtenant une liste des sorties du mod√®le avec la fonction FMTmodel.getouputs(). Effectuant une boucle for pour s√©lectionner la bonne sortie avec la fonction FMToutput.getname(). Imprimer les valeurs de la sortie avec la fonction FMTmodel.getvariabilities(FMToutput). Exportez le calendrier optimis√© du mod√®le dans un fichier .txt en Cr√©ant un nouvel objet FMTscheduleparser. R√©cup√©rant la solution du mod√®le √† chaque p√©riode avec une liste en utilisant LPModel.getsolution(period). Transformant la liste en un vecteur √âcriture du vecteur dans un fichier .txt avec FMTscheduleparser.write(). Vous pouvez utiliser les informations des pages pr√©c√©dentes de la documentation pour vous aider.\nLorsque vous avez termin√©, ou si vous √™tes bloqu√©.e, vous pouvez afficher la correction de cet exercice pour du code Python en cliquant sur le bouton \u0026ldquo;R√©v√©ler la correction\u0026rdquo; ci-dessous.\nCorrection R√©v√©ler la correction #%% CHARGEMENT DE FMT\r# Ici, on charge FMT directement, comme s'il avait √©t√© install√© avec pip.\rfrom FMT import Models\rfrom FMT import Parser\rfrom FMT import Version\r#%% CHARGEMENT DU MOD√àLE WOODSTOCK\r# Cr√©ation d'un objet pour lire le mod√®le (parser)\rmodelParser = Parser.FMTmodelparser()\r# Definition du chemin menant au mod√®le Woodstock\r# Le mod√®le Woodstock est fait de pleins de petits fichiers diff√©rents\r# On pointe vers le fichier .pri, qui contient la location de tous les petits fichiers du mod√®le.\r# WARNING : FMT a du mal avec les espaces dans les chemins. Essayez d'avoir un\r# chemin sans espaces.\rpathToWoodstockModel = \u0026quot;D:/TempCode/FMT/FMT/Examples/Models/TWD_land/TWD_land.pri\u0026quot;\r# On d√©finit le/les sc√©narios que l'on va lire\r# Les sc√©narios sont des ensembles de contraites et objectifs,\r# ou bien un planning d√©j√† fait que l'on va simuler.\rscenariosToSelect = [\u0026quot;LP\u0026quot;]\r# On lit le model gr√¢ce au parser. Celui-ci va renvoyer une liste de mod√®les\r# qu'il a d√©t√©ct√©. Dans notre cas, on n'en aura qu'un seul.\rlistOfModelsParsed = modelParser.readproject(pathToWoodstockModel, scenariosToSelect)\r# On charge le mod√®le parmis la liste des mod√®les renvoy√©s\r# Pour le charger correctement, il faut d√©crire le type de mod√®le que c'est, ainsi que des param√®tres importants.\r# Ici, le mod√®le sera un mod√®le lin√©raire spatialement r√©f√©renc√© (LP),\r# et on utilisera le solveur CLP pour le r√©soudre.\rLPModel = Models.FMTlpmodel(listOfModelsParsed[0], Models.FMTsolverinterface.CLP)\r#%% R√âSOLUTION DU MOD√àLE\r# Construction des p√©riodes du mod√®le\rfor period in range(1, 11):\rprint(LPModel.buildperiod())\r# R√©cup√©ration des contraintes et de l'objectif\rconstraintsOfModel = LPModel.getconstraints()\robjectiveOfModel = constraintsOfModel.pop(0)\r# D√©finition des contraintes et de l'objectif\rfor constraint in constraintsOfModel:\rprint(LPModel.setconstraint(constraint))\rprint(LPModel.setobjective(objectiveOfModel))\r# R√©solution du mod√®le\rLPModel.initialsolve()\r#%% INTERROGATION DE OSUPREC\r# On peut lire OSUPREC avant que le mod√®le soit r√©solu, mais les valeurs ne sont pas int√©r√©ssantes si c'est le cas.\routputWanted = \u0026quot;OSUPREC\u0026quot;\r# On r√©cup√®re les sorties du mod√®le\routputsOfModel = LPModel.getoutputs()\r# On fait une boucle autour de la liste des sorties pour selecitonner celle qui a le bon nom\rfor output in outputsOfModel:\rprint(output.getname())\rif output.getname() == outputWanted:\r# On affiche les mesures de \u0026quot;OSUPREC\u0026quot; dans le terminal\rprint(LPModel.getvariabilities([output]))\r# On sauvegarde les valeurs de OSUPREC pour les mettre au propre ensuite\rosuprecValues = LPModel.getvariabilities([output])\r# Ici, c'est un petit code qui permet d'afficher les sorties\r# en s'adaptant au fait que getvariabilities() renvoie leur valeur\r# minimum, maximum et moyenne print(\u0026quot;\\n\\n ###############################\u0026quot;)\rprint(\u0026quot;Values of \u0026quot; + outputWanted + \u0026quot; :\\n\u0026quot;)\rprint(\u0026quot;PERIOD\\t\\tMINIMUM\\t\\tMEAN\\t\\tMAXIMUM\u0026quot;)\rfor period in range(1, 11):\rprint(str(period) + \u0026quot;\\t\\t\\t\u0026quot; + str(round(osuprecValues[\u0026quot;L\u0026quot;+outputWanted][period-1], 2))\r+ \u0026quot;\\t\\t\u0026quot; + str(round(osuprecValues[\u0026quot;M\u0026quot;+outputWanted][period-1], 2))\r+ \u0026quot;\\t\\t\u0026quot; + str(round(osuprecValues[\u0026quot;U\u0026quot;+outputWanted][period-1], 2)))\r#%% ECRITURE DU PLANNING (cedule)\r# On d√©clare un objet permettant d'√©crire le programme/planning/c√©dule\rscheduleParser = Parser.FMTscheduleparser()\r# On r√©cup√®re la solution du mod√®le\rmodelSolution = list()\rfor period in range(1, 11):\rmodelSolution.append(LPModel.getsolution(period))\r# On √©crit le programme avec le scheduleParser\rmodelSolutionAsVector = [[i] for i in modelSolution]\rscheduleParser.write(modelSolution, r\u0026quot;D:/TempCode/FMT/FMT/Examples/programme.txt\u0026quot;)\r","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"fr","lastmod":1557010800,"objectID":"c5750174bd25f564fd2b5739892c8360","permalink":"https://bureau-du-forestier-en-chef.github.io/FMTdocs/fr/docs/basics/exercice_1/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/FMTdocs/fr/docs/basics/exercice_1/","section":"docs","summary":"Dans cet exercice, vous allez essayer d\u0026rsquo;utiliser FMT pour lire un sc√©nario, le r√©soudre, lire une de ses sorties, et exporter la solution.\nPour faire cet exercice, vous devez avoir install√© FMT sur votre ordinateur et avoir t√©l√©charg√© les fichiers d\u0026rsquo;exemples depuis le d√©p√¥t GitHub de FMT.","tags":null,"title":"Exercice 1","type":"book"},{"authors":null,"categories":null,"content":"Pour importer FMT que vous venez de compiler dans Python, vous devez avoir install√© Python et pip sur votre ordinateur.\nSi Python n\u0026rsquo;est pas install√© sur votre ordinateur, nous vous recommandons d\u0026rsquo;installer Miniconda, la version \u0026ldquo;l√©g√®re\u0026rdquo; de la c√©l√®bre distribution Python Anaconda. Miniconda contient Python, pip et de nombreux autres modules qui sont utiles pour utiliser FMT. Il existe deux fa√ßons d\u0026rsquo;importer FMT dans Python :\nEn utilisant sys.path.append. sys.path.append vous permet d\u0026rsquo;indiquer √† Python o√π trouver les biblioth√®ques de fonction de FMT.\nSi vous l\u0026rsquo;utilisez, le d√©but de vos scripts Python ressemblera √† ceci :\nimport sys\rsys.path.append(r\u0026quot;\u0026lt;Chemin vers le dossier FMT\u0026gt;/\u0026quot;)\rsys.path.append(r\u0026quot;\u0026lt;Chemin vers le dossier FMT\u0026gt;/Release/\u0026quot;)\rfrom FMT import Models\rfrom FMT import Parser\rfrom FMT import Core\rfrom FMT import Version\rdans lequel \u0026lt;Chemin vers le dossier FMT\u0026gt; sera remplac√© par l\u0026rsquo;emplacement du dossier o√π se trouvent les fichiers FMT que vous avez t√©l√©charg√©s depuis GitHub (et o√π se trouvent aussi les biblioth√®ques de fonction compil√©es de FMT, √† pr√©sent).\nCela peut cependant devenir redondant, ce qui rend la deuxi√®me option - l\u0026rsquo;installation avec pip - plus int√©ressante.\nEn utilisant pip et la Python wheel que vous avez compil√©e. Les Python wheels sont des fichiers qui contiennent tout ce qui est n√©cessaire pour qu\u0026rsquo;un module Python soit install√© dans votre environnement Python avec la commande pip. Une fois install√© de cette mani√®re, le module peut √™tre activ√© plus rapidement dans vos scripts Python.\nPour installer la Python wheel que vous avez compil√©e, utilisez la commande suivante dans une invite de commande (si vous avez install√© Python et pip ind√©pendamment d\u0026rsquo;Anaconda ou Miniconda), ou dans une invite de commande Anaconda :\npip install \u0026quot;\u0026lt;chemin vers le dossier FMT\u0026gt;\\build\\release\\bin\\Release/FMT-0.9.1-py3-none-any.whl\u0026quot;\rUne fois cette op√©ration effectu√©e, vous pourrez importer FMT dans vos scripts plus rapidement :\nfrom FMT import Models\rfrom FMT import Parser\rfrom FMT import Core\rfrom FMT import Version\rEt c\u0026rsquo;est tout, vous avez termin√© üéäüéâ! Maintenant, vous pouvez commencer √† utiliser FMT !\nSi vous avez eu des probl√®mes pendant le processus de t√©l√©chargement et d\u0026rsquo;installation de FMT, veuillez poster un probl√®me sur la page de probl√®mes du repository de FMT. ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"fr","lastmod":1557010800,"objectID":"3b4e5515a8180b52d201ea181148e8d7","permalink":"https://bureau-du-forestier-en-chef.github.io/FMTdocs/fr/docs/download_install/importing_in_python/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/FMTdocs/fr/docs/download_install/importing_in_python/","section":"docs","summary":"Pour importer FMT que vous venez de compiler dans Python, vous devez avoir install√© Python et pip sur votre ordinateur.\nSi Python n\u0026rsquo;est pas install√© sur votre ordinateur, nous vous recommandons d\u0026rsquo;installer Miniconda, la version \u0026ldquo;l√©g√®re\u0026rdquo; de la c√©l√®bre distribution Python Anaconda.","tags":null,"title":"Importer FMT dans Python","type":"book"},{"authors":null,"categories":null,"content":"Un petit rappel sur la signification de \u0026ldquo;spatialement r√©f√©renc√©\u0026rdquo;. On peut distinguer trois fa√ßons de prendre en compte l\u0026rsquo;espace dans un mod√®le :\nDans un mod√®le non spatial ou mod√®le spatialement implicite, les entit√©s (par exemple, les for√™ts, les animaux, les agents, etc.) ne sont pas directement associ√©es √† une position dans l\u0026rsquo;espace, mais la relation entre elles dans le mod√®le peut impliquer que seules certaines d\u0026rsquo;entre elles interagissent entre elles de mani√®re √† mimer une disposition spatiale. Dans un mod√®le spatialement r√©f√©renc√©, les entit√©s sont associ√©es √† des r√©gions de l\u0026rsquo;espace, mais pas √† une position pr√©cise dans ces r√©gions ; ces r√©gions peuvent √™tre non-continues. Les mod√®les de Woodstock sont par nature spatialement r√©f√©renc√©s, car ils consid√®rent des strates qui correspondent √† des for√™ts de m√™me composition et de m√™me √¢ge, qui peuvent √™tre dispers√©es en de nombreux endroits du paysage. Dans un mod√®le spatialement explicite, les entit√©s sont associ√©es √† des coordonn√©es pr√©cises dans l\u0026rsquo;espace, comme dans les pixels d\u0026rsquo;une carte matricielle. Le FMTsesmodel FMTsesmodel est un mod√®le particulier qui donne √† l\u0026rsquo;utilisateur la possibilit√© de spatialiser les solutions provenant de n\u0026rsquo;importe quelle classe FMTsrmodel, qui sont les mod√®les spatialement r√©f√©renc√©s (voir objets, lecture et interrogation de mod√®les et optimisation spatiallement r√©f√©renc√©e).\nNotez que nous ne parlons pas de l\u0026rsquo;optimisation d\u0026rsquo;un mod√®le spatialement explicite ; c\u0026rsquo;est une t√¢che assez complexe qui est encore sur le plan de route de FMT (et qui est le but de la classe FMTsamodel).\nclassDiagram\rFMTmodel \u0026lt;|-- FMTsemodel\rFMTsemodel \u0026lt;|-- FMTsamodel\rFMTsemodel \u0026lt;|-- FMTsesmodel\rFMTmodel \u0026lt;|-- FMTsrmodel\rFMTsrmodel \u0026lt;|-- FMTlpmodel\rFMTsrmodel \u0026lt;|-- FMTnssmodel\rAu lieu de √ßa, le FMTsesmodel va essayer de spatialiser le calendrier d\u0026rsquo;un FMTsrmodel en pla√ßant des blocs de coupe sur une carte. Il fait cela en faisant des it√©rations dans lesquelles il simule le placement de ces blocs, et en s√©lectionnant la meilleure solution trouv√©e.\nPour utiliser une m√©taphore, cela revient √† essayer de trouver une position gagnante aux √©checs si vous n\u0026rsquo;√™tes pas capable de la trouver en r√©fl√©chissant bien au placement de vos pi√®ces d\u0026rsquo;√©checs : vous pourriez essayer de placer vos pi√®ces au hasard de nombreuses, nombreuses fois, et vous demander √† chaque fois si vous avez gagn√©, ou si vous √™tes plus proche de la victoire, et si la position des pi√®ces d\u0026rsquo;√©checs respecte les r√®gles du jeu.\nIci, FMTsesmodel essaiera de placer les blocs de coupes selon la solution d\u0026rsquo;un FMTsrmodel (qui est un calendrier d\u0026rsquo;op√©rations foresti√®res appliqu√© √† des strates spatialement r√©f√©renc√©es). Son but sera de trouver le meilleur positionnement possible, en s\u0026rsquo;accommodant au mieux des contraintes lin√©aires et spatiales qui sont donn√©es pour leur placement, et en maximisant la valeur objective (par exemple, en maximisant le bois r√©colt√©).\nCependant, cette m√©thode a peu de chance de trouver le placement optimal, s\u0026rsquo;il existe ; √† la place, plus il y a d\u0026rsquo;it√©rations pour essayer de les placer, plus il y a de chance de trouver une solution qui se rapproche le plus possible d\u0026rsquo;un placement optimal des blocs coup√©s dans l\u0026rsquo;espace. C\u0026rsquo;est pourquoi ce processus repr√©sente ce que nous appelons une heuristique.\nL\u0026rsquo;espace dans FMT FMT utilise des FMTlayers pour repr√©senter toute solution spatialement explicite.\nUn FMTlayer peut √™tre compar√© √† un fichier raster ordinaire dans lequel les pixels peuvent contenir √† peu pr√®s n\u0026rsquo;importe quel type ou classe de peuplement forestier.\nDans le FMTsesmodel, nous utilisons la classe FMTspatialschedule pour repr√©senter une solution spatialement explicite, qui est elle-m√™me une FMTlayer de FMTlinegraph.\nChaque FMTlinegraph est une version lin√©aire du FMTgraph d√©crit dans optimisation spatiallement r√©f√©renc√©e. Cela signifie qu\u0026rsquo;ils montrent l\u0026rsquo;√©volution du FMTdevelopment √† l\u0026rsquo;int√©rieur du pixel du d√©but √† la fin des p√©riodes que nous voulons prendre en compte.\nLa classe FMTspatialschedule. La classe FMTspatialschedule contient une solution spatialement explicite sous la forme d\u0026rsquo;un FMTlayer.\nElle contient une fonction importante, FMTspatialschedule.getsolutionstatus(), qui imprime des informations importantes sur la fa√ßon dont la solution contenue dans le FMTspatialschedule atteint l\u0026rsquo;objectif du mod√®le.\nCette fonction donne √©galement une valeur de l\u0026rsquo;infaisabilit√© primaire, qui donne une id√©e de la mesure dans laquelle la solution actuelle ne respecte pas toutes les contraintes lin√©aires et spatiales du mod√®le.\nNotez que contrairement √† l\u0026rsquo;objet FMTschedule qui ne concerne qu\u0026rsquo;une seule p√©riode de temps (c\u0026rsquo;est pourquoi le code montr√© dans la section sur l\u0026rsquo;optimisation spatialement r√©f√©renc√©e contenait une boucle for autour du nombre de p√©riodes d\u0026rsquo;int√©r√™t lorsqu\u0026rsquo;il s\u0026rsquo;agissait de la classe FMTschedule), FMTspatialschedule contient une solution pour plusieurs p√©riodes de temps √† la fois.\nLe FMTlinegraph Comme dit pr√©c√©demment, la structure spatiale d\u0026rsquo;un FMTsesmodel est comme une carte raster faite de pixels, chaque pixel √©tant un FMTlinegraph.\nDans un FMTlinegraph, chaque noeud repr√©sente l\u0026rsquo;√©tat des strates √† l\u0026rsquo;int√©rieur du pixel et chaque lien repr√©sente une action (par exemple une coupe totale) ou une croissance naturelle, comme le montre l\u0026rsquo;image suivante :\nCependant, contrairement √† l\u0026rsquo;objet FMTgraph d√©crit dans la section sur l\u0026rsquo;optimisation spatialement r√©f√©renc√©e, le FMTlinegraph ne contient pas une √©num√©ration compl√®te de toutes les actions et √©tats possibles pour les strates dans le pixel : au lieu de cela, il ne contient qu\u0026rsquo;une solution, ou une √©volution possible pour les strates.\nFaire des transitions avec des sorties uniques Une limitation de la classe FMTlinegraph est que l\u0026rsquo;on ne peut pas utiliser de transitions √† sorties multiples, c\u0026rsquo;est-√†-dire des transitions qui aboutissent √† deux strates ou d\u0026rsquo;autres sorties, comme illustr√© ci-dessous :\nPar cons√©quent, vous devrez modifier les transitions d\u0026rsquo;un FMTmodel pour pouvoir les utiliser dans un FMTsesmodel.\n√Ä cette fin, vous pouvez utiliser la fonction FMTtransition.single(), qui transforme automatiquement les transitions √† sorties multiples en transitions √† sortie unique.\nUne fois que les transitions ont √©t√© transform√©es en transitions uniques, vous pouvez utiliser la fonction FMTsesmodel.settransitions() pour int√©grer les nouvelles transitions g√©n√©r√©es dans le FMTsesmodel.\n√âv√©nements spatiaux Le FMTspatialschedule garde √©galement la trace des zones affect√©es par des actions particuli√®res sous la forme d\u0026rsquo;√©v√©nements spatiaux avec la classe FMTevent, comme illustr√© ici :\nFMTevent peut repr√©senter tout type de perturbation spatialement explicite (coupe, feu, etc.). Il est associ√© √† la p√©riode de temps de l\u0026rsquo;√©v√©nement, et aux coordonn√©es de l\u0026rsquo;√©v√©nement spatial.\nLa carte foresti√®re initiale En tant que mod√®le spatialement explicite, le FMTsesmodel n√©cessite des informations spatialement explicites sur les for√™ts du paysage au d√©but de l\u0026rsquo;horizon de planification.\nPour obtenir ces informations √† partir d\u0026rsquo;un mod√®le Woodstock (qui peut avoir servi √† cr√©er un FMTlpmodel que vous avez optimis√© ; voir optimisation spatialement r√©f√©renc√©e), vous devrez r√©cup√©rer ces informations √† partir du fichier vectoriel qui sert de carte au mod√®le Woodstock. Ce fichier vectoriel contient des informations sur les attributs theme, age et lock pour chaque strate qui devront √™tre transf√©r√©es dans plusieurs rasters spatialement explicites.\nToutes ces informations seront contenues dans l\u0026rsquo;objet FMTforest, qui est l\u0026rsquo;√©quivalent de la carte du mod√®le, mais qui est bas√© sur un FMTlayer. Chaque pixel d\u0026rsquo;un objet FMTforest contient un objet FMTactualdevelopment.\nLa classe FMTareaparser peut √™tre utilis√©e pour g√©n√©rer le FMTforest n√©cessaire au FMTsesmodel, car elle contient des fonctions pour lire les cartes vectorielles ou matricielles d\u0026rsquo;un mod√®le Woodstock.\nFMTareaparser.vectormaptoFMTforest() vous permet de lire une carte vectorielle (shapefile) existante FMTareaparser.readrasters() vous permet de lire des cartes raster existantes Ces deux fonctions requi√®rent plusieurs param√®tres pour identifier correctement les th√®mes n√©cessaires, et pour sp√©cifier plusieurs caract√©ristiques spatiales de la classe FMTforest que vous allez cr√©er.\nUne fois que la FMTforest est cr√©√©e, elle doit √™tre fournie au FMTsesmodel en utilisant la fonction FMTsesmodel.setinitialmapping().\nUtilisation de nouveaux mots-cl√©s dans les fichiers Woodstock pour les contraintes spatiales Dans un mod√®le Woodstock habituel, les contraintes spatiales ne sont pas prises en compte. Cependant, vous aurez certainement besoin d\u0026rsquo;en utiliser pour une simulation spatiale avec le FMTsesmodel, afin de placer les blocs de coupes du planning optimis√©.\n√Ä cette fin, FMT peut lire deux nouveaux mots-cl√©s dans la section optimize d\u0026rsquo;un mod√®le Woodstock qui n\u0026rsquo;existent pas dans la syntaxe originale de Woodstock.\nCes mots-cl√©s sont _SIZE et _ADJACENCY.\n_SIZE doit √™tre utilis√© avec la syntaxe suivante dans la section optimize d\u0026rsquo;un mod√®le Woodstock :\n_SIZE(ACTION, NEIGHBORSIZE) \u0026gt;= \u0026lt;TAILLE EN PIXELS\u0026gt; \u0026lt;P√âRIODES\u0026gt;\nNotez que :\nACTION peut √©galement √™tre un agr√©gat de plusieurs actions, de sorte que plusieurs actions peuvent √™tre soumises √† la m√™me contrainte. NEIGHBORSIZE d√©crit comment l\u0026rsquo;√©v√©nement spatial s\u0026rsquo;est propag√© d\u0026rsquo;un pixel √† un autre pixel, en suivant ce graphique : \u0026lt;PERIODS\u0026gt; correspondent √† la p√©riode de temps pour laquelle il faut fixer la contrainte. Ainsi, la contrainte _SIZE peut donner une taille minimale ou maximale pour les √©v√©nements des actions sp√©cifi√©es, en nombre de pixels contigus. Elle entra√Ænera la cr√©ation de blocs spatiaux de pixels o√π l\u0026rsquo;action a √©t√© appliqu√©e.\nParall√®lement, _ADJACENCY est utilis√© avec la syntaxe suivante :\n_ADJACENCY(ACTION, GREENUP) \u0026gt;= \u0026lt;DISTANCE\u0026gt; \u0026lt;P√âRIODES\u0026gt;.\nAvec :\nACTION peut √† nouveau √™tre un agr√©gat de plusieurs actions, de sorte que plusieurs actions peuvent √™tre soumises √† la m√™me contrainte. \u0026lt;PERIODS\u0026gt; correspond √† nouveau √† la p√©riode de temps pour laquelle il faut fixer la contrainte. DISTANCE correspond √† la distance d\u0026rsquo;adjacence minimale ou maximale entre deux blocs spatiaux d\u0026rsquo;une ou plusieurs actions (dont la taille a √©t√© d√©finie par _SIZE). Ainsi, pour une DISTANCE \u0026gt;= 3, on aura ce qui suit : Les GREENUP correspondent au nombre de p√©riodes de temps pour lesquelles nous consid√©rons que deux √©v√©nements sont voisins. Par exemple, si GREENUP est √©gal √† 3, deux blocs spatiaux d\u0026rsquo;actions qui sont sous la distance maximale indiqu√©e par DISTANCE mais qui sont s√©par√©s temporellement par 4 p√©riodes ne seront pas consid√©r√©s comme spatialement adjacents ; cependant, s\u0026rsquo;ils √©taient s√©par√©s par 3, 2 ou 1 p√©riode, ou sont dans la m√™me p√©riode, ils seront consid√©r√©s comme spatialement adjacents. Faire la simulation avec FMTsesmodel.Greedyreferencebuild() Une fois que vous avez une solution/ un calendrier spatialement r√©f√©renc√© (voir optimisation spatialement r√©f√©renc√©) et que vous avez d√©fini le paysage initial pour le FMTsesmodel (voir les sections pr√©c√©dentes), vous pouvez utiliser FMTsesmodel.Greedyreferencebuild() pour faire la simulation proprement dite, et obtenir un calendrier d\u0026rsquo;op√©rations spatialement explicite bas√© sur le calendrier d\u0026rsquo;op√©rations spatialement r√©f√©renc√©.\nFMTsesmodel.Greedyreferencebuild() a besoin de la solution spatialement r√©f√©renc√©e d\u0026rsquo;un FMTlpmodel (ou d\u0026rsquo;un FMTnssmodel), sous la forme d\u0026rsquo;un objet FMTschedule. Cette solution d√©crit quel d√©veloppement (ou strates) est r√©colt√© pour une p√©riode donn√©e, avec quelle action, et sur quelle surface/zone.\nLe FMTschedule d\u0026rsquo;un FMTlpmodel ou FMTnssmodel solutionn√© peut √™tre r√©cup√©r√© en utilisant leur fonction getsolution(). Cependant, la fonction r√©cup√©rera la solution pour une p√©riode ; vous devrez boucler autour des p√©riodes pour obtenir les solutions pour chaque p√©riode d\u0026rsquo;int√©r√™t, et pour indiquer si vous voulez que la solution prenne en compte les d√©veloppements bloqu√©s (locked).\nFMTsesmodel.Greedyreferencebuild() construira une solution spatialement explicite √† partir d\u0026rsquo;une solution spatialement r√©f√©renc√©e pour une p√©riode donn√©e. Avec le FMTschedule pour la p√©riode, la fonction aura besoin d\u0026rsquo;un argument randomiterations qui est le nombre maximal d\u0026rsquo;it√©rations faites par l\u0026rsquo;algorithme avant qu\u0026rsquo;il ne s\u0026rsquo;arr√™te quand aucune augmentation de la valeur de la fonction d\u0026rsquo;objectif (maximisation de l\u0026rsquo;objectif) ou diminution de la valeur d\u0026rsquo;infaisabilit√© primaire n\u0026rsquo;a √©t√© trouv√©e. Cela s\u0026rsquo;explique par le fait que la simulation est constitu√©e d\u0026rsquo;it√©rations au cours desquelles le mod√®le tente de placer les blocs de coupes dans l\u0026rsquo;espace conform√©ment au calendrier d\u0026rsquo;op√©rations spatialement r√©f√©renc√©es afin d\u0026rsquo;augmenter la fonction d\u0026rsquo;objectif du mod√®le (par exemple, le volume r√©colt√©) tout en respectant les contraintes lin√©aires et spatiales donn√©es (dont la d√©viation aux contraintes est repr√©sent√©e par la valeur d\u0026rsquo;infaisabilit√© primaire).\nUne derni√®re entr√©e est un num√©ro de graine al√©atoire (seed) qui sera utilis√© pour g√©n√©rer des nombres al√©atoires utilis√©s pour cr√©er les blocs de coupes √† chaque it√©ration. Ce syst√®me de graine permet √† FMT d\u0026rsquo;utiliser des nombres al√©atoires qui sont \u0026ldquo;r√©plicables\u0026rdquo; ; c\u0026rsquo;est-√†-dire que si vous gardez la m√™me graine, FMT obtiendra les m√™mes nombres al√©atoires, et fera exactement les m√™mes simulations.\nVoici une repr√©sentation du fonctionnement de l\u0026rsquo;algorithme de simulation en pratique :\nEn R, le code pour utiliser FMTsesmodel.Greedyreferencebuild() ressemblera √† ceci :\nlibrary(FMT) # Charge FMT dans R\rif (new(FMTversion)$hasfeature(\u0026quot;OSI\u0026quot;)) # V√©rifie si FMT a √©t√© compil√© avec OSI en cr√©ant un nouvel objet FMTversion, et en utilisant la fonction hasfeature().\r{\r# Lit et r√©soud un FMTlpmodel; voir la section sur l'optimisation spatialement r√©f√©renc√©e pour plus de d√©tails\rnewparser \u0026lt;- new(FMTmodelparser)\rmodelslist \u0026lt;- newmodelparser$readproject(\u0026quot;Models/TWD_land/TWD_land.pri\u0026quot;, c(\u0026quot;Spatial\u0026quot;), TRUE, TRUE, TRUE)\rsolverinterface \u0026lt;- list(CLP=1,MOSEK=2,CPLEX=3,GUROBI=4)\rlpmodel \u0026lt;- new(FMTlpmodel,modelslist[[1]],solverinterface$MOSEK)\remptyschedule \u0026lt;- new(FMTschedule)\rfor (period in 1:10)\r{\rprint(lpmodel$buildperiod(emptyschedule,FALSE,1)$str())\r}\rallmodelconstraints \u0026lt;- lpmodel$getconstraints()\rmodelobjective \u0026lt;- allmodelconstraints[[1]]\rmodelconstraints \u0026lt;- allmodelconstraints[2:length(allmodelconstraints)]\rfor (constraint in modelconstraints)\r{\rprint(lpmodel$setconstraint(constraint)$str())\r}\rprint(lpmodel$setobjective(modelobjective)$str())\r# Ici, on test si le mod√®le a √©t√© r√©solu tout en le r√©solvant, vu que initialsolve() r√©soud le mod√®le et renvoie \u0026quot;true\u0026quot; s'il a √©t√© r√©solu\rif (lpmodel$initialsolve())\r{\r# On cr√©er un nouveau mod√®le de simulation spatialement explicite, en se basant sur le contenu de lpmodel\rsimulationmodel \u0026lt;- new(FMTsesmodel, lpmodel)\r# On fait en sorte que les transitions du mod√®le aient une seule sortie, et on les modifient si n√©c√©ssaire\rsingletransition \u0026lt;- list()\rfor (transition in simulationmodel$gettransitions())\r{\r# Le +1 est fait pour s'adapter au fait que FMT √©tant cod√© en C++, il fonctionne en base 0 (les listes commencent √† l'indice 0); alors que R fonctionne en base 1.\rsingletransitions[[length(singletransitions) + 1]] \u0026lt;- transition$single()\r}\rsimulationmodel$settransitions(singletransitions)\r# On pr√©pare un parseur pour lire la carte initiale des for√™ts\rareaparser \u0026lt;- new(FMTareaparser)\r# On d√©finit o√π est-ce que le raster des for√™ts se trouve avec les informations initiales rasterslocation \u0026lt;- \u0026quot;../Models/TWD_land/rasters\u0026quot;\rageraster \u0026lt;- file.path(rasterlocation,\u0026quot;AGE.tif\u0026quot;)\r# On lit les diff√©rents rasters qui contiennent les diff√©rents \u0026quot;themes\u0026quot; (ou attributs) initiaux des for√™ts en faisant\r# une boucle autour de tous les themes d√©finits dans le mod√®le, et en mettant le nom de ces rasters dans une liste\rthemesrasters \u0026lt;- list()\rthemeid \u0026lt;- 1\rfor (theme in simulationmodel$gethemes())\r{\rthemesrasters[[length(themesrasters) + 1]] \u0026lt;- file.path(rasterslocation, paste(\u0026quot;THEME\u0026quot;, paste0(themeID), \u0026quot;.tif\u0026quot;, sep = \u0026quot;\u0026quot;))\rthemeid \u0026lt;- themeid + 1\r}\r# Maintenant que l'on a tous les rasters, on creer un object FMTforest en lisant tous les rasters de themes, qui contiennent les informations initiales des for√™ts\rinitialforestmap \u0026lt;- areaparser$readrasters(simulationmodel$getthemes(), unlist(themerasters), ageraster, 1, 0.0001, \u0026quot;\u0026quot;)\r# On donne les donn√©es initiales de for√™t au mod√®le spatialement explicite\rsimulationmodel$setinitialmapping(initialforestmap)\r# Maintenant, on trouve la solution spatialement explicite pour chaque p√©riode de temps,\r# en se basant sur la solution du lpmodel pour cette p√©riode.\r# On stoppera la recherche de l'algorithme lorsqu'il n'aura pas trouv√© de meilleurs placements pour augmenter la fonction objectif\r# ou bien r√©duire l'infasibilit√© primaire pendant 10 it√©rations.\rfor (period in 1:10)\r{\rprint(simulationmodel$greedyreferencebuild(lpmodel$getsolution(period,FALSE), 10, 0, 0.0001))\r}\r}\r} else { # Si le mod√®le n'as pas √©t√© compil√© avec OSI, on affiche une erreur\rprint(\u0026quot;FMT needs to be compiled with OSI\u0026quot;)\r}\rL\u0026rsquo;√©quivalent en Python est :\nimport sys\rfrom FMT import Models\rfrom FMT import Parser\rfrom FMT import Version\rif __name__ == \u0026quot;__main__\u0026quot;:\rif Version.FMTversion().hasfeature(\u0026quot;OSI\u0026quot;):\r# Lit et r√©soud un FMTlpmodel; voir la section sur l'optimisation spatialement r√©f√©renc√©e pour plus de d√©tails\rnewmodelparser= Parser.FMTmodelparser()\rpath = \u0026quot;Models/TWD_Land/TWD_Land.pri\u0026quot;\rscenarios = [\u0026quot;Spatial\u0026quot;]\rmodelslist = newmodelparser.readproject(path, scenarios)\rlpmodel = Models.FMTlpmodel(modelslist[0], Models.FMTsolverinterface.CLP)\rfor period in range(1, 11):\rprint(lpmodel.buildperiod())\rconstraints = lpmodel.getconstraints()\robjective = constraints.pop(0)\rfor constraint in constraints:\rlpmodel.setconstraint(constraint)\rlpmodel.setobjective(objective)\r# Ici, on test si le mod√®le a √©t√© r√©solu tout en le r√©solvant, vu que initialsolve() r√©soud le mod√®le et renvoie \u0026quot;true\u0026quot; s'il a √©t√© r√©solu\rif lpmodel.initialsolve():\r# On cr√©er un nouveau mod√®le de simulation spatialement explicite, en se basant sur le contenu de lpmodel\rsimulationmodel = Models.FMTsesmodel(lpmodel)\r# On fait en sorte que les transitions du mod√®le aient une seule sortie, et on les modifient si n√©c√©ssaire\rsingletransitions = []\rfor transition in simulationmodel.gettransitions():\rsingletransitions.append(transition.single())\rsimulationmodel.settransitions(singletransitions)\r# On pr√©pare un parseur pour lire la carte initiale des for√™ts\rareaparser = Parser.FMTareaparser()\r# On d√©finit o√π est-ce que le raster avec les informations initiales des for√™ts se trouvent\rrasterslocation = \u0026quot;../Models/TWD_land/rasters/\u0026quot;\rageraster = os.path.join(rasterslocation, \u0026quot;AGE.tif\u0026quot;)\r# On lit les diff√©rents rasters qui contiennent les diff√©rents \u0026quot;themes\u0026quot; (ou attributs) initiaux des for√™ts en faisant\r# une boucle autour de tous les th√®mes d√©finis dans le mod√®le, et en mettant le nom de ces rasters dans une liste\rthemesrasters = []\rthemeid = 1\rfor theme in simulationmodel.getthemes():\rthemesrasters.append(os.path.join(rasterslocation, \u0026quot;THEME\u0026quot; + str(themeid) + \u0026quot;.tif\u0026quot;))\rthemeid += 1\r# Maintenant que l'on a tous les rasters, on creer un object FMTforest en lisant tous les rasters de th√®mes, qui contiennent les informations initiales des for√™ts\rinitialforestmap = areaparser.readrasters(simulationmodel.getthemes(), themesrasters, ageraster, 1, 0.0001)\r# On donne les donn√©es initiales de for√™t au mod√®le spatialement explicite\rsimulationmodel.setinitialmapping(initialforestmap)\r# Maintenant, on trouve la solution spatialement explicite pour chaque p√©riode de temps,\r# en se basant sur la solution du lpmodel pour cette p√©riode.\r# On stoppera la recherche de l'algorithme lorsqu'il n'aura pas trouv√© de meilleurs placements pour augmenter la fonction objectif\r# ou bien r√©duire l'infasibilit√© primaire pendant 10 it√©rations.\rfor period in range(1, 11):\rprint(simulationmodel.greedyreferencebuild(lpmodel.getsolution(period), 10))\relse:\rprint(\u0026quot;FMT needs to be compiled with OSI\u0026quot;) # Si le mod√®le n'as pas √©t√© compil√© avec OSI, on affiche une erreur\rLa sortie des deux codes devrait √™tre la suivante. Il y a beaucoup de choses √† traiter, mais nous les examinerons plus pr√©cis√©ment dans la prochaine section :\nReading D:/TempCode/FMT/FMT/Examples/Models/TWD_land/TWD_Land.pri FMT 0.9.1, build: Oct 22 2021 11:52:53\rFri Feb 18 12:44:56 2022\rReading scenario Spatial\rFMTexc(41)Ignoring: YBM_RTM_MEH at line 44 FMTsection(6)Yield\rFMTexc(39)Undefined _death action: _DEATH FMTsection(4)Action\rDone reading Fri Feb 18 12:44:56 2022\rColumns: 69 Rows: 34 Vertices: 62 Edges: 69 Transfer Rows: 34 Output Rows: 0 Output Columns: 0\rColumns: 173 Rows: 86 Vertices: 126 Edges: 173 Transfer Rows: 86 Output Rows: 0 Output Columns: 0\rColumns: 320 Rows: 156 Vertices: 208 Edges: 320 Transfer Rows: 156 Output Rows: 0 Output Columns: 0\rColumns: 510 Rows: 244 Vertices: 308 Edges: 510 Transfer Rows: 244 Output Rows: 0 Output Columns: 0\rColumns: 730 Rows: 350 Vertices: 426 Edges: 730 Transfer Rows: 350 Output Rows: 0 Output Columns: 0\rColumns: 986 Rows: 474 Vertices: 562 Edges: 986 Transfer Rows: 474 Output Rows: 0 Output Columns: 0\rColumns: 1278 Rows: 616 Vertices: 716 Edges: 1278 Transfer Rows: 616 Output Rows: 0 Output Columns: 0\rColumns: 1606 Rows: 776 Vertices: 888 Edges: 1606 Transfer Rows: 776 Output Rows: 0 Output Columns: 0\rColumns: 1992 Rows: 964 Vertices: 1088 Edges: 1992 Transfer Rows: 964 Output Rows: 0 Output Columns: 0\rColumns: 2436 Rows: 1180 Vertices: 1316 Edges: 2436 Transfer Rows: 1180 Output Rows: 0 Output Columns: 0\rCoin0506I Presolve 76 (-1143) rows, 226 (-2211) columns and 898 (-5379) elements\rClp0035I 0 Primal 100 Dual 842632.63 Complementarity 842579 - 0 fixed, rank 76\rClp0035I 1 Primal 225.4735 Dual 307283.38 Complementarity 318751.96 - 0 fixed, rank 76\rClp0035I 2 Primal 7266.7264 Dual 146511.3 Complementarity 174120.63 - 0 fixed, rank 76\rClp0035I 3 Primal 35053.074 Dual 105622.03 Complementarity 73089.174 - 0 fixed, rank 76\rClp0035I 4 Primal 38320.846 Dual 70235.705 Complementarity 33405.695 - 0 fixed, rank 76\rClp0035I 5 Primal 44403.19 Dual 55792.68 Complementarity 11676.178 - 0 fixed, rank 76\rClp0035I 6 Primal 46801.335 Dual 50712.255 Complementarity 3964.085 - 0 fixed, rank 76\rClp0035I 7 Primal 47534.239 Dual 48865.81 Complementarity 1331.5805 - 0 fixed, rank 76\rClp0035I 8 Primal 47849.045 Dual 48152.188 Complementarity 303.14539 - 0 fixed, rank 76\rClp0035I 9 Primal 47959.375 Dual 48049.655 Complementarity 90.456075 - 0 fixed, rank 76\rClp0035I 10 Primal 47999.651 Dual 48009.843 Complementarity 10.204147 - 0 fixed, rank 76\rClp0035I 11 Primal 47998.773 Dual 48000.252 Complementarity 1.4873248 - 0 fixed, rank 76\rClp0035I 12 Primal 47999.994 Dual 48000.002 Complementarity 0.0085757189 - 0 fixed, rank 76\rClp0035I 13 Primal 48000 Dual 48000 Complementarity 0.00011127406 - 0 fixed, rank 70\rClp0035I 14 Primal 48000 Dual 48000 Complementarity 1.102542e-06 - 0 fixed, rank 63\rClp0035I 15 Primal 48000 Dual 48000.074 Complementarity 8.4407744e-09 - 20 fixed, rank 68\rClp0035I 16 Primal 48000 Dual 48000 Complementarity 6.8286544e-11 - 20 fixed, rank 65\rClp0042I Optimal\rClp0046I At end primal/dual infeasibilities 0.00015298276/0.10009623, complementarity gap 4.668539e-06, objective 48000\rClp0006I 0 Obj 48000 Dual inf 0.015282 (8)\rClp0006I 152 Obj 48000\rClp0000I Optimal - objective value 48000\rClp0006I 0 Obj 48000\rClp0000I Optimal - objective value 48000\rClp0006I 0 Obj 48000\rClp0000I Optimal - objective value 48000\rCoin0511I After Postsolve, objective 48000, infeasibilities - dual 0 (0), primal 0 (0)\rClp0032I Optimal objective 48000 - 16 iterations time 0.022, Presolve 0.01\rIteration 0 Primal Inf(0.000000) Obj(40475.320000)\rIteration 10 Primal Inf(0.000000) Obj(44085.320000)\rStalled after 16 iterations Skipping\r{'ACARIBOU': 0.981677543988014, 'COUPETOTALE': 0.9817026645791909, 'Objective': 42453.599999999984, 'Primalinfeasibility': 0.0, 'Total': 0.9816850800303768}\rIteration 0 Primal Inf(2310.400000) Obj(40143.200000)\rIteration 10 Primal Inf(216.600000) Obj(42237.000000)\rIteration 20 Primal Inf(0.000000) Obj(42453.600000)\rSolution stuck after 30 iterations Skipping\r{'ACARIBOU': 1.0278470194296387, 'COUPETOTALE': 0.9116104392588846, 'Objective': 42453.599999999984, 'PLANTATION': 0.927291117344956, 'Primalinfeasibility': 1.4551915228366852e-11, 'Total': 0.9264994202031354}\rIteration 0 Primal Inf(2108.240000) Obj(42453.600000)\rIteration 10 Primal Inf(2108.240000) Obj(42453.600000)\rIteration 20 Primal Inf(635.360000) Obj(42453.600000)\rSolution stuck after 27 iterations Skipping\r{'ACARIBOU': 0.8973831819756647, 'COUPETOTALE': 0.9033560325101042, 'Objective': 42453.599999999984, 'PLANTATION': 0.911737449703183, 'Primalinfeasibility': 635.3600000000297, 'Total': 0.9025186555019942}\rIteration 0 Primal Inf(8779.520000) Obj(42453.600000)\rIteration 10 Primal Inf(8779.520000) Obj(42453.600000)\rIteration 20 Primal Inf(808.640000) Obj(42453.600000)\rSolution stuck after 29 iterations Skipping\r{'ACARIBOU': 0.8771528754492212, 'COUPETOTALE': 0.889988896215573, 'Objective': 42453.599999999984, 'PLANTATION': 0.8765659747164727, 'Primalinfeasibility': 808.6400000000212, 'Total': 0.8822416209150494}\rIteration 0 Primal Inf(6931.200000) Obj(42453.600000)\rIteration 10 Primal Inf(6931.200000) Obj(42453.600000)\rIteration 20 Primal Inf(1111.880000) Obj(42453.600000)\rSolution stuck after 30 iterations Skipping\r{'ACARIBOU': 0.8952525436304627, 'COUPETOTALE': 0.88445, 'Objective': 42453.599999999984, 'PLANTATION': 0.9411700993142432, 'Primalinfeasibility': 1111.8800000000338, 'Total': 0.9032996680762417}\rIteration 0 Primal Inf(9342.680000) Obj(42453.600000)\rIteration 10 Primal Inf(3638.880000) Obj(42453.600000)\rIteration 20 Primal Inf(3638.880000) Obj(42453.600000)\rIteration 30 Primal Inf(3638.880000) Obj(42453.600000)\rSolution stuck after 35 iterations Skipping\r{'ACARIBOU': 968.4932690882329, 'COUPETOTALE': 0.9397466289394396, 'Objective': 42453.599999999984, 'PLANTATION': 2367.8747068875177, 'Primalinfeasibility': 3638.8800000000047, 'Total': 1.0649491134961293}\rIteration 0 Primal Inf(16606.000000) Obj(30309.560000)\rStalled after 9 iterations Skipping\r{'ACARIBOU': 1.3474601235578203, 'COUPETOTALE': 0.9825519488602954, 'Objective': 32937.64000000001, 'PLANTATION': 1.0022853728788734, 'Primalinfeasibility': 13977.919999999998, 'Total': 1.0087375080393326}\rIteration 0 Primal Inf(119576.200000) Obj(32937.640000)\rIteration 10 Primal Inf(65859.400000) Obj(32937.640000)\rIteration 20 Primal Inf(39247.920000) Obj(32937.640000)\rSolution stuck after 28 iterations Skipping\r{'ACARIBOU': 1054.0980891170655, 'COUPETOTALE': 0.845845565618348, 'Objective': 32937.64000000001, 'PLANTATION': 0.9266686936638757, 'Primalinfeasibility': 39247.9200000001, 'Total': 0.8969889215263215}\rIteration 0 Primal Inf(58611.960000) Obj(27522.640000)\rStalled after 6 iterations Skipping\r{'ACARIBOU': 536.8311084909311, 'COUPETOTALE': 0.4341194959208162, 'Objective': 27667.040000000005, 'PLANTATION': 0.9541653732993195, 'Primalinfeasibility': 58467.560000000114, 'Total': 0.7846327502399465}\rIteration 0 Primal Inf(79145.640000) Obj(26208.600000)\rIteration 10 Primal Inf(77340.640000) Obj(27667.040000)\rStalled after 14 iterations Skipping\r{'ACARIBOU': 10491.125109295706, 'COUPETOTALE': 0.3982872281191633, 'Objective': 27667.040000000005, 'PLANTATION': 1.0028031096555103, 'Primalinfeasibility': 77340.64000000012, 'Total': 0.8163283360740083}\rAnalyser les sorties de FMTsesmodel.Greedyreferencebuild() FMTsesmodel.Greedyreferencebuild() retourne des informations sur la meilleure solution qui a √©t√© trouv√©e ; c\u0026rsquo;est-√†-dire le meilleur placement spatial des blocs de coupes que l\u0026rsquo;algorithme a √©t√© capable de trouver en optimisant la fonction d\u0026rsquo;objectif, tout en respectant les contraintes lin√©aires et spatiales qui ont √©t√© donn√©es par l\u0026rsquo;utilisateur.\nEn particulier, FMTsesmodel.Greedyreferencebuild() indique 4 informations importantes :\nMot Description Objective Valeur de la fonction d\u0026rsquo;objectif de la solution spatialement explicite. Primalinfeasibilities Valeur d\u0026rsquo;infaisabilit√© primaire de la solution spatialement explicite, par rapport aux contraintes qui ont √©t√© donn√©es. Une valeur proche de 0 signifie que la solution est 100% faisable selon les contraintes lin√©aires et spatiales. Total Proportion totale de la zone de la planification spatialement r√©f√©renc√©e pass√©e en entr√©e qui a √©t√© spatialis√©e avec succ√®s par l\u0026rsquo;algorithme. Actionname x Proportion de la zone spatialis√©e d\u0026rsquo;une action donn√©e x de la solution originale spatialement r√©f√©renc√©e pass√©e √† la fonction. Maintenant, examinons les r√©sultats de la section pr√©c√©dente pour essayer de comprendre ce qui s\u0026rsquo;est pass√©.\nTout d\u0026rsquo;abord, nous voyons les m√™mes sorties habituelles qui indiquent que FMT lit, puis r√©sout le mod√®le en utilisant le solveur CLP :\nReading D:/TempCode/FMT/FMT/Examples/Models/TWD_land/TWD_Land.pri FMT 0.9.1, build: Oct 22 2021 11:52:53\rFri Feb 18 12:44:56 2022\rReading scenario Spatial\rFMTexc(41)Ignoring: YBM_RTM_MEH at line 44 FMTsection(6)Yield\rFMTexc(39)Undefined _death action: _DEATH FMTsection(4)Action\rDone reading Fri Feb 18 12:44:56 2022\rColumns: 69 Rows: 34 Vertices: 62 Edges: 69 Transfer Rows: 34 Output Rows: 0 Output Columns: 0\rColumns: 173 Rows: 86 Vertices: 126 Edges: 173 Transfer Rows: 86 Output Rows: 0 Output Columns: 0\rColumns: 320 Rows: 156 Vertices: 208 Edges: 320 Transfer Rows: 156 Output Rows: 0 Output Columns: 0\rColumns: 510 Rows: 244 Vertices: 308 Edges: 510 Transfer Rows: 244 Output Rows: 0 Output Columns: 0\rColumns: 730 Rows: 350 Vertices: 426 Edges: 730 Transfer Rows: 350 Output Rows: 0 Output Columns: 0\rColumns: 986 Rows: 474 Vertices: 562 Edges: 986 Transfer Rows: 474 Output Rows: 0 Output Columns: 0\rColumns: 1278 Rows: 616 Vertices: 716 Edges: 1278 Transfer Rows: 616 Output Rows: 0 Output Columns: 0\rColumns: 1606 Rows: 776 Vertices: 888 Edges: 1606 Transfer Rows: 776 Output Rows: 0 Output Columns: 0\rColumns: 1992 Rows: 964 Vertices: 1088 Edges: 1992 Transfer Rows: 964 Output Rows: 0 Output Columns: 0\rColumns: 2436 Rows: 1180 Vertices: 1316 Edges: 2436 Transfer Rows: 1180 Output Rows: 0 Output Columns: 0\rCoin0506I Presolve 76 (-1143) rows, 226 (-2211) columns and 898 (-5379) elements\rClp0035I 0 Primal 100 Dual 842632.63 Complementarity 842579 - 0 fixed, rank 76\rClp0035I 1 Primal 225.4735 Dual 307283.38 Complementarity 318751.96 - 0 fixed, rank 76\rClp0035I 2 Primal 7266.7264 Dual 146511.3 Complementarity 174120.63 - 0 fixed, rank 76\rClp0035I 3 Primal 35053.074 Dual 105622.03 Complementarity 73089.174 - 0 fixed, rank 76\rClp0035I 4 Primal 38320.846 Dual 70235.705 Complementarity 33405.695 - 0 fixed, rank 76\rClp0035I 5 Primal 44403.19 Dual 55792.68 Complementarity 11676.178 - 0 fixed, rank 76\rClp0035I 6 Primal 46801.335 Dual 50712.255 Complementarity 3964.085 - 0 fixed, rank 76\rClp0035I 7 Primal 47534.239 Dual 48865.81 Complementarity 1331.5805 - 0 fixed, rank 76\rClp0035I 8 Primal 47849.045 Dual 48152.188 Complementarity 303.14539 - 0 fixed, rank 76\rClp0035I 9 Primal 47959.375 Dual 48049.655 Complementarity 90.456075 - 0 fixed, rank 76\rClp0035I 10 Primal 47999.651 Dual 48009.843 Complementarity 10.204147 - 0 fixed, rank 76\rClp0035I 11 Primal 47998.773 Dual 48000.252 Complementarity 1.4873248 - 0 fixed, rank 76\rClp0035I 12 Primal 47999.994 Dual 48000.002 Complementarity 0.0085757189 - 0 fixed, rank 76\rClp0035I 13 Primal 48000 Dual 48000 Complementarity 0.00011127406 - 0 fixed, rank 70\rClp0035I 14 Primal 48000 Dual 48000 Complementarity 1.102542e-06 - 0 fixed, rank 63\rClp0035I 15 Primal 48000 Dual 48000.074 Complementarity 8.4407744e-09 - 20 fixed, rank 68\rClp0035I 16 Primal 48000 Dual 48000 Complementarity 6.8286544e-11 - 20 fixed, rank 65\rClp0042I Optimal\rClp0046I At end primal/dual infeasibilities 0.00015298276/0.10009623, complementarity gap 4.668539e-06, objective 48000\rClp0006I 0 Obj 48000 Dual inf 0.015282 (8)\rClp0006I 152 Obj 48000\rClp0000I Optimal - objective value 48000\rClp0006I 0 Obj 48000\rClp0000I Optimal - objective value 48000\rClp0006I 0 Obj 48000\rClp0000I Optimal - objective value 48000\rCoin0511I After Postsolve, objective 48000, infeasibilities - dual 0 (0), primal 0 (0)\rClp0032I Optimal objective 48000 - 16 iterations time 0.022, Presolve 0.01\rEnsuite, nous pouvons voir les lignes qui correspondent aux simulations de la fonction FMTsesmodel.Greedyreferencebuild() :\nIteration 0 Primal Inf(0.000000) Obj(40475.320000)\rIteration 10 Primal Inf(0.000000) Obj(44085.320000)\rStalled after 16 iterations Skipping\r{'ACARIBOU': 0.981677543988014, 'COUPETOTALE': 0.9817026645791909, 'Objective': 42453.599999999984, 'Primalinfeasibility': 0.0, 'Total': 0.9816850800303768}\rIteration 0 Primal Inf(2310.400000) Obj(40143.200000)\rIteration 10 Primal Inf(216.600000) Obj(42237.000000)\rIteration 20 Primal Inf(0.000000) Obj(42453.600000)\rSolution stuck after 30 iterations Skipping\r{'ACARIBOU': 1.0278470194296387, 'COUPETOTALE': 0.9116104392588846, 'Objective': 42453.599999999984, 'PLANTATION': 0.927291117344956, 'Primalinfeasibility': 1.4551915228366852e-11, 'Total': 0.9264994202031354}\rIteration 0 Primal Inf(2108.240000) Obj(42453.600000)\rIteration 10 Primal Inf(2108.240000) Obj(42453.600000)\rIteration 20 Primal Inf(635.360000) Obj(42453.600000)\rSolution stuck after 27 iterations Skipping\r{'ACARIBOU': 0.8973831819756647, 'COUPETOTALE': 0.9033560325101042, 'Objective': 42453.599999999984, 'PLANTATION': 0.911737449703183, 'Primalinfeasibility': 635.3600000000297, 'Total': 0.9025186555019942}\rIteration 0 Primal Inf(8779.520000) Obj(42453.600000)\rIteration 10 Primal Inf(8779.520000) Obj(42453.600000)\rIteration 20 Primal Inf(808.640000) Obj(42453.600000)\rSolution stuck after 29 iterations Skipping\r{'ACARIBOU': 0.8771528754492212, 'COUPETOTALE': 0.889988896215573, 'Objective': 42453.599999999984, 'PLANTATION': 0.8765659747164727, 'Primalinfeasibility': 808.6400000000212, 'Total': 0.8822416209150494}\rIteration 0 Primal Inf(6931.200000) Obj(42453.600000)\rIteration 10 Primal Inf(6931.200000) Obj(42453.600000)\rIteration 20 Primal Inf(1111.880000) Obj(42453.600000)\rSolution stuck after 30 iterations Skipping\r{'ACARIBOU': 0.8952525436304627, 'COUPETOTALE': 0.88445, 'Objective': 42453.599999999984, 'PLANTATION': 0.9411700993142432, 'Primalinfeasibility': 1111.8800000000338, 'Total': 0.9032996680762417}\rIteration 0 Primal Inf(9342.680000) Obj(42453.600000)\rIteration 10 Primal Inf(3638.880000) Obj(42453.600000)\rIteration 20 Primal Inf(3638.880000) Obj(42453.600000)\rIteration 30 Primal Inf(3638.880000) Obj(42453.600000)\rSolution stuck after 35 iterations Skipping\r{'ACARIBOU': 968.4932690882329, 'COUPETOTALE': 0.9397466289394396, 'Objective': 42453.599999999984, 'PLANTATION': 2367.8747068875177, 'Primalinfeasibility': 3638.8800000000047, 'Total': 1.0649491134961293}\rIteration 0 Primal Inf(16606.000000) Obj(30309.560000)\rStalled after 9 iterations Skipping\r{'ACARIBOU': 1.3474601235578203, 'COUPETOTALE': 0.9825519488602954, 'Objective': 32937.64000000001, 'PLANTATION': 1.0022853728788734, 'Primalinfeasibility': 13977.919999999998, 'Total': 1.0087375080393326}\rIteration 0 Primal Inf(119576.200000) Obj(32937.640000)\rIteration 10 Primal Inf(65859.400000) Obj(32937.640000)\rIteration 20 Primal Inf(39247.920000) Obj(32937.640000)\rSolution stuck after 28 iterations Skipping\r{'ACARIBOU': 1054.0980891170655, 'COUPETOTALE': 0.845845565618348, 'Objective': 32937.64000000001, 'PLANTATION': 0.9266686936638757, 'Primalinfeasibility': 39247.9200000001, 'Total': 0.8969889215263215}\rIteration 0 Primal Inf(58611.960000) Obj(27522.640000)\rStalled after 6 iterations Skipping\r{'ACARIBOU': 536.8311084909311, 'COUPETOTALE': 0.4341194959208162, 'Objective': 27667.040000000005, 'PLANTATION': 0.9541653732993195, 'Primalinfeasibility': 58467.560000000114, 'Total': 0.7846327502399465}\rIteration 0 Primal Inf(79145.640000) Obj(26208.600000)\rIteration 10 Primal Inf(77340.640000) Obj(27667.040000)\rStalled after 14 iterations Skipping\r{'ACARIBOU': 10491.125109295706, 'COUPETOTALE': 0.3982872281191633, 'Objective': 27667.040000000005, 'PLANTATION': 1.0028031096555103, 'Primalinfeasibility': 77340.64000000012, 'Total': 0.8163283360740083}\rCette premi√®re ligne nous informe sur la premi√®re solution trouv√©e par la simulation : dans cette solution, la valeur d\u0026rsquo;infaisabilit√© primaire est 0, ce qui signifie que la solution est 100% faisable, et que les contraintes lin√©aires et spatiales que nous avons mises sont toujours respect√©es. Cependant, nous pouvons voir que la valeur de la fonction objectif est inf√©rieure √† celle trouv√©e par la r√©solution du mod√®le spatialement r√©f√©renc√© (qui √©tait 48000).\nIteration 0 Primal Inf(0.000000) Obj(40475.320000)\rApr√®s 10 solutions g√©n√©r√©es, nous pouvons voir que l\u0026rsquo;infaisabilit√© primaire est toujours 0, et que la valeur de la fonction objectif a augment√© √† 448085.32.\nIteration 10 Primal Inf(0.000000) Obj(44085.320000)\rEnsuite, FMT termine les simulations de la premi√®re p√©riode en nous indiquant pourquoi il a arr√™t√© de chercher, et la proportion de chaque action qu\u0026rsquo;il a pu placer dans l\u0026rsquo;espace.\nIci, pour la premi√®re p√©riode, FMT a arr√™t√© la recherche en indiquant que l\u0026rsquo;algorithme s\u0026rsquo;est stabilis√© (stalled). Pendant ce temps, il a √©t√© capable de spatialiser 98% de l\u0026rsquo;action ACARIBOU, et 98% de l\u0026rsquo;action COUPETOTALE.\nStalled after 16 iterations Skipping\r{'ACARIBOU': 0.981677543988014, 'COUPETOTALE': 0.9817026645791909, 'Objective': 42453.599999999984, 'Primalinfeasibility': 0.0, 'Total': 0.9816850800303768}\rLe processus se r√©p√®te ensuite pour les 9 autres p√©riodes. √Ä chaque fois, FMT commence par une premi√®re it√©ration de placement des actions dans l\u0026rsquo;espace en essayant de respecter les contraintes. Ensuite, l\u0026rsquo;algorithme se termine lorsqu\u0026rsquo;il est soit stalled (stabilis√©), soit stuck (bloqu√©), ce qui signifie qu\u0026rsquo;il ne peut plus am√©liorer la solution ou r√©duire l\u0026rsquo;infaisabilit√© primale. Il affiche alors le nombre d\u0026rsquo;actions qu\u0026rsquo;il a pu placer dans l\u0026rsquo;espace.\nNotez que stalled et stuck ont deux significations diff√©rentes :\nStalled signifie que l\u0026rsquo;algorithme a g√©n√©r√© exactement les m√™mes solutions (le m√™me placement des coupes dans l\u0026rsquo;espace) que ses 3 derni√®res it√©rations, ce qui implique qu\u0026rsquo;il ne peut g√©n√©rer aucune nouvelle solution. Cela peut se produire lorsque les contraintes font que le nombre de solutions potentielles est limit√©, ce qui signifie que l\u0026rsquo;algorithme les aura rapidement toutes essay√©es. Stuck signifie que l\u0026rsquo;algorithme a pu g√©n√©rer diff√©rentes solutions, mais que toutes ces nouvelles solutions ont une valeur de fonction d\u0026rsquo;objectif qui n\u0026rsquo;est pas sup√©rieure aux pr√©c√©dentes, ou bien que ces nouvelles solutions ne peuvent pas r√©duire l\u0026rsquo;infaisabilit√© primaire. Apr√®s un nombre d\u0026rsquo;it√©rations correspondant aux arguments randomiterations fournis √† FMTsesmodel.Greedyreferencebuild() sans aucune am√©lioration, l\u0026rsquo;algorithme s\u0026rsquo;arr√™te. Pour la deuxi√®me p√©riode, nous pouvons voir :\nIteration 0 Primal Inf(2310.400000) Obj(40143.200000)\rIteration 10 Primal Inf(216.600000) Obj(42237.000000)\rIteration 20 Primal Inf(0.000000) Obj(42453.600000)\rSolution stuck after 30 iterations Skipping\r{'ACARIBOU': 1.0278470194296387, 'COUPETOTALE': 0.9116104392588846, 'Objective': 42453.599999999984, 'PLANTATION': 0.927291117344956, 'Primalinfeasibility': 1.4551915228366852e-11, 'Total': 0.9264994202031354}\rPour la troisi√®me p√©riode, nous pouvons voir :\nIteration 0 Primal Inf(2108.240000) Obj(42453.600000)\rIteration 10 Primal Inf(2108.240000) Obj(42453.600000)\rIteration 20 Primal Inf(635.360000) Obj(42453.600000)\rSolution stuck after 27 iterations Skipping\r{'ACARIBOU': 0.8973831819756647, 'COUPETOTALE': 0.9033560325101042, 'Objective': 42453.599999999984, 'PLANTATION': 0.911737449703183, 'Primalinfeasibility': 635.3600000000297, 'Total': 0.9025186555019942}\rEt ainsi de suite jusqu\u0026rsquo;√† la 10√®me p√©riode.\nVous devriez maintenant en savoir assez pour commencer √† utiliser le FMT par vous-m√™me. Si vous avez d\u0026rsquo;autres questions, veuillez contacter Guillaume Cyr du BFEC. Vous pouvez √©galement installer FMT sur votre ordinateur en suivant la section T√©l√©chargement et installation.\n","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"fr","lastmod":1557010800,"objectID":"793eb7f10f8d83f2a8f6adcc3e722198","permalink":"https://bureau-du-forestier-en-chef.github.io/FMTdocs/fr/docs/basics/spatially_explicit_simulation/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/FMTdocs/fr/docs/basics/spatially_explicit_simulation/","section":"docs","summary":"Un petit rappel sur la signification de \u0026ldquo;spatialement r√©f√©renc√©\u0026rdquo;. On peut distinguer trois fa√ßons de prendre en compte l\u0026rsquo;espace dans un mod√®le :\nDans un mod√®le non spatial ou mod√®le spatialement implicite, les entit√©s (par exemple, les for√™ts, les animaux, les agents, etc.","tags":null,"title":"Simulation spatiallement explicite","type":"book"},{"authors":["Guillaume Cyr,ing.f.,M.Sc."],"categories":[],"content":"Mise √† jour d\u0026rsquo;un mod√®le Github | Documentation\nPourquoi la mise √† jour dans les mod√®les? graph TD;\r1--\u003e2;\r1--\u003e3;\r1[\"La carte n'est pas √† jour\"];\r2[\"Les donn√©es ne sont pas disponibles\"];\r3[\"La p√©riode pr√©c√©dente de calcul n'est pas termin√©e\"];\rLes d√©savantages de la mise √† jour Peut causer des biais dans les analyses d\u0026rsquo;impact Sous-estimer l\u0026rsquo;impact d\u0026rsquo;un retrait de superficie Surestimer le retrait d\u0026rsquo;une balise de traitement sylvicole Ralentit le solveur math√©matique Solutions multiples Certains solveurs ne peuvent pas r√©soudre le mod√®le Causer des erreurs de manipulation (ex: changer les bornes avec _GOAL) Causer des biais dans l\u0026rsquo;interpr√©tation carbone du mod√®le Causer des erreurs d\u0026rsquo;interpr√©tation La mise √† jour non spatiale graph TD;\r1--\u003e2;\r1--\u003e3;\r1--\u003e4;\r1--\u003e5;\r1--\u003e6;\r2--\u003e7;\r3--\u003e7;\r4--\u003e7;\r5--\u003e7;\r6--\u003e7;\r1[\"R√©soudre le mod√®le (1 p√©riode ou +)\"]\r2[\"Mettre √† jour la section area\"]\r3[\"Mettre √† jour les contraintes\"]\r4[\"Mettre √† jour les actions\"]\r5[\"Mettre √† jour les transitions\"]\r6[\"Mettre √† jour les yields\"]\r7[\"R√©√©crire le mod√®le\"]\r√Ä venir Mise √† jour de la carte? Perte en pr√©cision Plus complexe Alternative Mise √† jour non spatiale avec tous les th√®mes Des Questions? Github | Documentation\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"fr","lastmod":-62135596800,"objectID":"8962150326a62f00fe3009485bd7ee73","permalink":"https://bureau-du-forestier-en-chef.github.io/FMTdocs/fr/slides/fmt_modelupdate/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/FMTdocs/fr/slides/fmt_modelupdate/","section":"slides","summary":"Comprendre la mise √† jour d'un FMTmodel","tags":["FMT"],"title":"La mise √† jour de la 1er p√©riode dans FMT","type":"slides"},{"authors":["Guillaume Cyr,ing.f.,M.Sc."],"categories":[],"content":"Presolve et Postsolve Github | Documentation\nLe processus journey\rtitle Planification sans presolve\rsection Avant r√©solution\rConstruction du probl√®me: 1: FMT\rsection R√©solution\rInterior point: 1: Solveur\rSimplex: 1: Solveur\rsection Apr√®s R√©solution\rUtilisation du mod√®le: 5: FMT\rLe processus journey\rtitle Planification avec presolve\rsection Avant r√©solution\rPresolve: 5: FMT\rConstruction du probl√®me: 5: FMT\rsection R√©solution\rInterior point: 5: Solveur\rSimplex: 5: Solveur\rsection Apr√®s R√©solution\rPostsolve: 5: FMT\rUtilisation du mod√®le: 5: FMT\rLe presolve impact stateDiagram\rPresolve\rstate Presolve {\rdirection LR\rTemps --\u003e Construction\rTemps --\u003e R√©solution\rTaille --\u003e Probl√®me\r}\rComment? graph TD;\r1--\u003e2;\r1--\u003e3;\r2--\u003e5;\r2--\u003e9\r2--\u003e8;\r2--\u003e4;\r2--\u003e6;\r2--\u003e7;\r3--\u003e4;\r3--\u003e6;\r3--\u003e7;\r1[\"Presolve\"];\r2[\"R√©duire le nombre\"];\r3[\"Simplifier\"];\r4[\"Th√®mes\"];\r5[\"Yields\"];\r6[\"Actions\"];\r7[\"Transitions\"];\r8[\"Contraintes\"];\r9[\"D√©veloppements\"]\rTh√®mes flowchart LR\rB{\"Un seul attribut?\"} -- Oui --\u003eC[\"√âlimine le th√®me\"]\rB -- Non --\u003eD{\"Attributs statiques?\"}\rD -- Oui --\u003eC\rD -- Non --\u003eE{\"Attribut inutile?\"}\rsubgraph R√©duction du nombre d'√©l√©ments\rE -- Oui --\u003eF[\"√âliminer l'attribut\"]\rF --\u003e E\rE -- Non --\u003eG[\"Aggr√©gat inutile?\"]\rG -- Oui --\u003eH[\"√âliminer l'aggr√©gat\"]\rH --\u003e G\rend\rG -- Non --\u003eI[\"Nouveau th√®me\"]\rYields flowchart LR\rB{\"Contr√¥le l'op√©rabilit√©?\"} -- Oui --\u003eC[\"Conserve le yield\"]\rB -- Non --\u003eD{\"Masque sur attribut inutile?\"}\rD -- Oui --\u003eE[\"√âlimine le yield\"]\rD -- Non --\u003eC\rActions flowchart LR\rB{\"Aucune op√©rabilit√©?\"} -- Oui --\u003eC[\"√âlimine l'action\"]\rB -- Non --\u003eD{\"Ligne d'op√©rabilit√© inutile?\"}\rsubgraph R√©duction du nombre d'√©l√©ments\rD -- Oui --\u003eE{\"√âliminer cette op√©rabilit√©\"}\rE --\u003e D\rD -- Non --\u003eF{\"Op√©rabilit√© √©quivalente?\"}\rF -- Oui --\u003eG{\"Regroupement des op√©rabilit√©s\"}\rG --\u003e F\rF -- Non --\u003eH[\"Nouvelle action\"]\rend\rTransitions flowchart LR\rB{\"Aucune action?\"} -- Oui --\u003eC[\"√âlimine la transition\"]\rB -- Non --\u003eD{\"Ligne de source inutile?\"}\rsubgraph R√©duction du nombre d'√©l√©ments\rD -- Oui --\u003eE{\"√âliminer cette source et ses targets\"}\rE --\u003e D\rD -- Non --\u003eF{\"Source √©quivalente?\"}\rF -- Oui --\u003eG{\"Regroupement des sources\"}\rG --\u003e F\rF -- Non --\u003eH[\"Nouvelle transition\"]\rend\rD√©veloppements flowchart LR\rB{\"D√©veloppement avec attributs inutilis√©s?\"} -- Oui --\u003eC[\"Regroupement avec un autre d√©veloppement\"]\rB -- Non --\u003eD[\"Conserve le d√©veloppement\"]\rC --\u003e B\rContraintes flowchart LR\rB{\"RHS de 0?\"} -- Oui --\u003eC[\"Output d'actions?\"]\rC -- Oui --\u003eD[\"Transformer la contrainte en yields et op√©rabilit√© d'action et l'√©liminer\"]\rC -- Non --\u003eE[\"Output d'inventaire?\"]\rE -- Oui --\u003eD\rE -- Non --\u003eF[\"Conserver la contrainte\"]\rPostsolve graph TD;\r1--\u003e2;\r1--\u003e3;\r3--\u003e4;\r3--\u003e5;\r3--\u003e6;\r3--\u003e7;\r3--\u003e8;\r1[\"Postsolve\"];\r2[\"R√©ajustement du Graph\"];\r3[\"R√©attribution\"];\r4[\"Th√®mes\"];\r5[\"Actions\"];\r6[\"Transitions\"];\r7[\"Outputs\"];\r8[\"Contraintes\"];\rExemple Le pr√©solve est r√©alis√© sur le sc√©nario nomm√© Globalreplanning 10 it√©rations de presolve sont r√©alis√©es Le mod√®le poss√®de 11299 d√©veloppements, l‚Äôoriginal (506 de plus) Le mod√®le poss√®de 13 th√®mes, l‚Äôoriginal (7 de plus) Le mod√®le poss√®de 276 yields, l‚Äôoriginal (89 de plus) Le mod√®le poss√®de 14 actions, l‚Äôoriginal (19 de plus) Le mod√®le poss√®de 14 transitions, l‚Äôoriginal (19 de plus) Le mod√®le poss√®de 1103 outputs, l‚Äôoriginal (1074 de plus) Le mod√®le poss√®de 130 contraintes, l‚Äôoriginal (9 de plus) Des Questions? Github | Documentation\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"fr","lastmod":-62135596800,"objectID":"6f7a0c5ff92ae75e90f6554aa4d5c19b","permalink":"https://bureau-du-forestier-en-chef.github.io/FMTdocs/fr/slides/fmt_presolve/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/FMTdocs/fr/slides/fmt_presolve/","section":"slides","summary":"Comprendre le presolve et le postsolve","tags":["FMT","Presolve"],"title":"Le presolve et le postsolve dans FMT","type":"slides"},{"authors":[],"categories":[],"content":"Les bases de FMT Github | Documentation\nQu\u0026rsquo;est-ce que FMT ? librairie open source objets et fonctions en C++, R ou Python √Ä quoi sert FMT ? planification foresti√®re comment r√©colter des for√™ts pour maximiser des objectifs (e.g. rendement) ? sous certaines contraintes (e.g. legislation, technologie, etc.) En pratique, √† quoi √ßa sert ? Lecture de mod√®les Woodstock Simulation de paysages forestiers Optimisation / R√©optimisation de mod√®les Planification (en utilisant des √©v√©nements stochastiques) R√©solution des heuristiques d\u0026rsquo;agr√©gation Planification des blocs de r√©colte Comment est-ce que √ßa marche ? code source en c++ compilation en Python et R Interface de programmation (C++)Interface de programmation (C+\u0026hellip;RRPython 2Python 2Python 3Python 3Text is not SVG - cannot display\nPourquoi FMT ? Projet du Bureau du Forestier en Chef du Qu√©bec.\n2017 : Besoin d\u0026rsquo;automatiser l\u0026rsquo;utilisation de mod√®les Woodstock 2018 : Besoin de relier Woodstock √† GCBM pour estimations de carbone 2019 √† aujourd\u0026rsquo;hui : Augmentation des performances et fonctionalit√©s Le futur Interface utilisateur¬∑rice (GUI) Optimisation spatialement explicite Meilleurs outputs (sorties) Comment √ßa marche, du code interactif ? Reveal.js permet de mettre en valeur des lignes par intermitence. Ici, la 2, puis la 8, puis la 13. Fantastique pour parler du code au fur et √† mesure.\nlibrary(FMT) # Charge FMT dans R\rif (new(FMTversion)$hasfeature(\"OSI\")) # V√©rifie si FMT a √©t√© compil√© avec OSI en cr√©ant un nouvel objet FMTversion, et en utilisant la fonction hasfeature().\r{\r# Cr√©er un objet parser pour lire les fichiers du mod√®le\rnewmodelparser \u003c- new(FMTmodelparser)\r# Lit le projet avec le parser en sp√©cifiant que l'on veut lire le sc√©nario \"LP\" (il peut y avoir diff√©rents sc√©narios dans un seul mod√®le)\rmodelslist \u003c- newmodelparser$readproject(\"Models/TWD_land/TWD_land.pri\", c(\"LP\"), TRUE, TRUE, TRUE)\rmodel_scenario_lp \u003c- modelslist[[1]]\r# On r√©cup√®re le nom du mod√®le\rprint(model_scen_lp$getname())\r} else { # Si le mod√®le n'as pas √©t√© compil√© avec OSI, on affiche une erreur\rprint(\"FMT needs to be compiled with OSI\")\r}\rLa suite Objets, parsing et interrogation\n^ Lien vers la pr√©sentation suivante, si besoin.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"fr","lastmod":-62135596800,"objectID":"d4f6b4f11db24a19668a46e99cc8f498","permalink":"https://bureau-du-forestier-en-chef.github.io/FMTdocs/fr/slides/fmt_bases_intro/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/FMTdocs/fr/slides/fmt_bases_intro/","section":"slides","summary":"Comprendre ce que FMT est, et ce qu'il fait.","tags":[],"title":"Les bases de FMT","type":"slides"},{"authors":["Guillaume Cyr,ing.f.,M.Sc."],"categories":[],"content":"FMT o√π en somme-nous? Github | Documentation\nC\u0026rsquo;est quoi FMT? F: For√™t M: Mod√©lis√©e T: dans le Temps C\u0026rsquo;est quoi FMT? graph TD;\r2--\u003e14;\r1--\u003e2--\u003e5;\r1--\u003e3--\u003e6;\r1--\u003e4--\u003e7;\r3--\u003e8;\r3--\u003e12;\r3--\u003e15;\r4--\u003e13;\r5--\u003e9;\r5--\u003e10;\r5--\u003e11;\r1[\"FMT API\"];\r2[\"C++\"];\r3[\"Python\"];\r4[\"Cran R\"];\r5[\"Interface\"];\r6[\"Replanification\"];\r7[\"Base de donn√©es\"];\r8[\"BFEC-GCBM\"];\r9[\"Planification\"];\r10[\"Spatialisation\"];\r11[\"BFECOPT\"];\r12[\"Analyses diverses\"];\r13[\"Autre\"];\r14[\"Tests\"];\r15[\"Machine Learning\"];\rComment on test FMT? pie title Les tests de FMT\r\"Syntaxe\" : 3.5\r\"Unit√©s spatiales\" : 5.3\r\"Planification\" : 61.4\r\"Replanification\" : 5.3\r\"Spatialisation\" : 7.0\r\"Machine Learning\" : 7.0\r\"Presolve\" : 3.5\r\"Analyses autre\" : 7.0\rL\u0026rsquo;√©volution des versions flowchart LR;\r1 --\u003e 6;\r6 --\u003e 7;\r7 --\u003e 8;\r8 --\u003e 9;\r1 --\u003e 11 --\u003e 6;\r1 --\u003e 2 --\u003e 6;\r2 --\u003e 7;\r2 --\u003e 8;\r2 --\u003e 9;\r1 --\u003e 3 --\u003e 6;\r3 --\u003e 7;\r3 --\u003e 8;\r3 --\u003e 9;\r1 --\u003e 4 --\u003e 9;\r1 --\u003e 10 --\u003e 8;\r10 --\u003e 9;\r1 --\u003e 5 --\u003e 9;\r1[\"Master\"]\r2[\"Replanification\"]\r3[\"BFEcopt\"]\r4[\"Machine Learning\"]\r5[\"type II\"]\r6[\"0.9.1\"]\r7[\"0.9.2\"]\r8[\"0.9.3\"]\r9[\"0.9.4 en d√©veloppement\"]\r10[\"Presolve\"]\r11[\"Autre\"]\rLes nouveaut√©s 0.9.4 Presolve R√©duit la taille du mod√®le √† un mod√®le √©quivalent Diminue la vitesse de construction Diminue la vitesse de r√©solution Type II Diminue la taille de la matrice Diminue la vitesse de construction et de r√©solution Diminue l\u0026rsquo;utilisation de la m√©moire de l\u0026rsquo;ordinateur par le solveur Syntaxe carbone Permet d\u0026rsquo;int√©grer les r√©servoirs et flux de carbone √† m√™me les yields Permet d\u0026rsquo;obtenir un bilan de carbone spatialement r√©f√©renc√© et spatialement explicite La Documentation stateDiagram\rCode --\u003e Doxygen(78%)\rDoxygen(78%) --\u003e Pr√©sentations\rstate Doxygen(78%) {\rdirection LR\rC++ --\u003e Python\rC++ --\u003e R\r}\rstate Pr√©sentations {\rFormation --\u003e Replanification\rFormation --\u003e ClubFMT\rFormation --\u003e Carbone\rAutre\r}\rDoxygen(78%) --\u003e GitHub\rstate GitHub {\rFonctionnement\rInstallation\rMachine Learning\rSpatialisation\r}\rDocumentation √† venir Github Replanification Syntaxe Spatialisation Carbone (yields) Replanification Continuer √† documenter les fonctions (78%) Les travaux gantt\rdateFormat YYYY-MM-DD\rtitle Les travaux dans FMT\rexcludes weekends\rsection Interface\rProgrammation :done,des1,2021-12-15,2022-03-07 Test Phase 1 : des2,2022-02-25,2022-03-11\rTest Phase 2 : des3,2022-03-16,2022-03-30\rTest Phase 3 :active,des4,2022-05-03,2022-05-16\rCorrections : des5, 2022-03-11,2022-03-20\rParall√©lisation BFEcopt/Planification : des6, 2022-03-11,2022-04-28\rMise √† jour de la cache : des8, 2022-04-20,2022-05-20\rMigration du code : crit,des9, 2022-05-02,2022-05-09\rAjout playback et parallisation : des10, 2022-05-20,2022-06-03\rAjout de BFECopt : des11, 2022-06-03,2022-06-09\rAjout de la replanification :des12, 2022-06-09,2022-06-30\rsection Formations\rClubFMTh√© :done,des1,2021-12-15,2022-02-30\rFormation Replanification :active,des2,2022-03-22,2022-06-15\rsection Machine Learning\rPhase 1.2 (D√©veloppement de syntaxe carbone) :done,des1,2021-12-15,2022-04-15\rMise en place d'une pr√©sentation : des2,2022-02-15,2022-04-08\rPhase 2.1 (Spatialisation de la r√©colte) :active,des3,2021-12-15,2022-06-30\rsection G√©n√©rale\rPresolve :done,des1,2021-12-15,2022-04-01\rMigration √† Visual Studio 2022 :crit,active,des2,2022-04-15,2022-05-20\rD√©bogage : des3,2021-12-15,2022-06-30\rLes futurs projets potentiels Replanification spatialement explicite Permettre d\u0026rsquo;obtenir un effet de spatialisation √† travers la replanification Utilisation d\u0026rsquo;√©v√®nements stochastiques spatiaux Inclure les enjeux op√©rationels Changements climatiques Type I Corriger des comportements ind√©sirable des CPF (existant depuis des ann√©es) Respect des strat√©gies de A √† Z par le solveur Lien avec SELES Passer les hypoth√®ses de nos mod√®les √† SELES Permettre l\u0026rsquo;optimisation du bilan de carbone Explorer les mod√®les de pr√©diction qu\u0026rsquo;on pourrait int√©grer directement Biomasse Facteur de productivit√© en fonction du sc√©nario Rcp Des Questions? Github | Documentation\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"fr","lastmod":-62135596800,"objectID":"a6d0dc8f9482eb5c0a140aaaec1a7c0d","permalink":"https://bureau-du-forestier-en-chef.github.io/FMTdocs/fr/slides/fmt_mise_a_jour280422/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/FMTdocs/fr/slides/fmt_mise_a_jour280422/","section":"slides","summary":"Comprendre ce que FMT est, et ce qu'il fait.","tags":["FMT","FORAC","carbone","Machine Learning","Interface"],"title":"Les diff√©rents projets avec FMT","type":"slides"},{"authors":["Guillaume Cyr,ing.f.,M.Sc."],"categories":[],"content":"Planification foresti√®re √† l‚Äôaide du Machine Learning (Mise √† jour 2023) Github | Documentation\nLes probl√©matiques Notre bilan carbone est difficile √† obtenir rapidement Pour tous les r√©servoirs de l\u0026rsquo;√©cosyst√®me Pour la productivit√© nette de l\u0026rsquo;√©cosyst√®me La localisation des activit√©s sylvicoles pouvant am√©liorer le bilan carbone est un enjeu complexe Le calcul du bilan de carbone forestier pour un mod√®le de planification est complexe L‚Äôoptimisation spatialement explicite de la localisation des travaux sylvicoles peut √™tre tr√®s difficile √† r√©aliser avec un mod√®le math√©matique classique Les objectifs Obtention du bilan de carbone rapidement (Article #1) Tous les r√©servoirs de l‚Äô√©cosyst√®me La productivit√© nette de l‚Äô√©cosyst√®me Bilan carbone avec l\u0026rsquo;IA stateDiagram\rdirection LR\rstate IA_par_pixel {\rdirection LR\rstate Intrants {\rdirection LR\rDerni√®res_perturbations\rVolume_de_feuillus_tol√©rants\rVolume_de_feuillus_intol√©rants\rVolume_de_r√©sineux\r}\rIntrants --\u003e R√©servoir\rstate R√©servoir {\rBiomasse_a√©rienne\rBiomasse_souterraine\rBois_mort\rCarbone_du_sol\rLiti√®re\r}\rIntrants --\u003e Flux\rState Flux {\rProductivit√©_nette_de_l'√©cosyst√®me\r}\r}\rIA_par_pixel --\u003e Entrainement\rState Entrainement {\rdirection LR\rCPF2328 --\u003e Global\rCPF2328 --\u003e Pessi√®re\rCPF2328 --\u003e Sapini√®re\rCPF2328 --\u003e √ârabli√®re\r}\rEntrainement --\u003e Validation\rState Validation {\rdirection LR\rSpatial --\u003e 07152\rNon_Spatial --\u003e 07152\rSpatial --\u003e 02751\rNon_Spatial --\u003e 02751\rSpatial --\u003e 08665\rNon_Spatial --\u003e 08665\rSpatial --\u003e 08762\rNon_Spatial --\u003e 08762\rSpatial --\u003e 09751\rNon_Spatial --\u003e 09751\r}\rLes objectifs G√©n√©ration de planification spatialement explicite (Article #2) Maximisant le bilan carbone Planification spatiale par IA stateDiagram\rdirection LR\rMod√®le --\u003e FMTsamodel\rstate FMTsamodel {\rdirection LR\rstate Intrants {\rdirection LR\r(i)Cellule --\u003e √Çge\r(i)Cellule --\u003e Op√©rabilit√©\r(i)Globale --\u003e Taille_des_blocs\r(i)Globale --\u003e D√©lai_dadjacence\r}\rIntrants --\u003e IA\rstate G√©n√©rateur {\rdirection LR\rCalcul_2328 --\u003e Apprentisage\r}\rState IA {\rG√©n√©rateur --\u003e Pr√©diction\rstate Pr√©diction {\r(o)Spatiaux --\u003e Blocs_de_coupes\r(o)Non_spatiaux --\u003e faisabilit√©\r(o)Non_spatiaux --\u003e Bilan_carbone\r}\r}\rIA --\u003e Optimisation\rState Optimisation {\rValidation --\u003e Am√©lioration\r}\r}\rFMTsamodel --\u003e Solution\rgantt\rdateFormat YYYY-MM-DD\rtitle Projet FORAC\rexcludes weekends\rsection IA estimateur carbone\rScript d'entrainement :done,des1,2021-04-01,2021-09-01 Script d'utilisation : done,des2,2021-04-01,2021-09-01\rS√©lection du mod√®le : done,des2,2021-04-01,2021-05-01\rRapport : done,des3,2021-09-01,2021-10-01\rInstallation FMT release :done,des4,2021-10-01,2021-11-01\rPytorch √† C++ : done,des5, 2021-10-01,2021-12-01\rInstallation FMT debug : done,des6, 2021-12-01,2022-03-01\rImpl√©mentation : done,des8, 2021-12-01,2022-03-01\r√âcriture de l'article estimateur de carbone\t:des16,2022-09-01,2023-04-01\rTest et validation avec mod√®les r√©els\t:active,des15,2022-10-01,2023-05-01\rsection IA Planification spatiale\rTest et extension √† la planification r√©f√©renc√©e : done,des9, 2022-02-01,2022-05-01\rMise en place d'un plan : done,des10, 2021-12-01,2022-02-01\rLien FMT avec Python avec exemple : done,des11, 2022-01-01,2022-04-01\rMod√®le IA de spatialisation mim√©tique:\tdone,des12, 2022-04-01,2022-10-01\rMod√®le IA d'√©valuation de planification spatialis√©e :crit,des13,2022-09-01,2023-03-01\rMod√®le IA de spatialisation (avec carbone) :crit,des14,2023-02-01,2023-08-01\r√âcriture de l'article planification foresti√®re\t:des17,2023-04-01,2023-08-01\rR√©sultats concrets de la phase 1 Nouvelle syntaxe pour la section yield Voir dans examples/Models/TWD_land/Scenarios/Predictors D√©veloppement d\u0026rsquo;un nouveau type de yield \u0026ldquo;*YM\u0026rdquo; Nouvelle syntaxe Yields {\rIntrants:\r- GFI = Volume de feuillus intol√©rants\r- GFT = Volume de feuillus tol√©rants\r- GF = Volume feuillu total\r- GR = Volume r√©sineux total\r}\r*YM ? ? ?\rNEP _PRED(nep_carbon,GFI,GFT,GF,GR)\r{\rExtrants:\r- AG_Biomass_C = Biomasse a√©rienne\r- BG_Biomass_C = Biomasse souterraine\r- Deadwood_C = Bois mort\r- Litter_C = Litti√®re\r- Soil_C = Sol\r}\rNouvelle Syntaxe Outputs ;Inventaire de la productivit√© nette de l'√©cosyst√®me en (c)\r*OUTPUT NEP_Total\r*SOURCE ? ? ? _INVENT NEP\r;Inventaire de la biomasse an√©rienne et souterraine en (c)\r*OUTPUT Biomasse_Total\r*SOURCE ? ? ? _INVENT AG_Biomass_C + ? ? ? _INVENT BG_Biomass_C\r;Inventaire du carbone du sol en (c)\r*OUTPUT Sols_Total\r*SOURCE ? ? ? _INVENT Soil_C\rgantt\rdateFormat YYYY-MM-DD\rtickInterval month\raxisFormat %b%d\rtitle Validation\rexcludes weekends\rsection √âchelle Globale\rApprentissage (29 UA) :done,des1,2023-01-09,2023-01-23 Tests avec spatialisation : done,des2,2023-03-01,2023-04-01\rAnalyse des r√©sultats : done,des3,2023-04-01,2023-04-17\rPr√©sentation : active,des4,2023-05-01,2023-05-02\rsection √âchelle des r√©gions √©cologiques\rApprentissage (29 UA) :done,des5,2023-01-02,2023-01-16\rTester l'IA (08665) : done,des6,2023-03-06,2023-03-27\rsection Optimisation du NEP\rTester avec 02751 : done,des7,2023-04-03,2023-04-24\rGCBM vs IA (02751) Les mod√®les d\u0026rsquo;IA test√©s R√©gion √©cologique trois mod√®les (Pessi√®re,Sapini√®re,√ârabli√®re) entrain√©s avec calcul-2328 Global un mod√®le entrain√© avec calcul-2328 Les types de mod√©lisations Spatial (cellules de 14 ha) Non spatial (√† l\u0026rsquo;√©chelle de la strate) Notre r√©f√©rence GCBM GCBM vs IA (02751) GCBM vs IA (02751) Constats IA vs GCBM Le mod√®le d\u0026rsquo;IA par r√©gion √©cologique performe moins bien Sous estime le carbone des r√©servoirs √Ä le plus grand √©cart avec le bilan des √©missions nettes de GCBM Le mod√®le d\u0026rsquo;IA Global est le meilleur Les sc√©narios spatialement explicites se collent √† GCBM Les sc√©narios non spatiaux performent moins bien L\u0026rsquo;objetif du projet √©tait l\u0026rsquo;utilisation avec des mod√®les spatialement explicites Pourquoi ces diff√©rences? Les r√©sultats de l\u0026rsquo;IA diff√®rent de GCBM car: L\u0026rsquo;IA suppose le feu comme perturbation historique GCBM utilise plus d\u0026rsquo;intrants Temp√©rature annuelle moyenne Pr√©cipitations Transitions apr√®s perturbation Le mod√®le par r√©gion √©cologique performe moins bien car: Manque de donn√©es par mod√®le Les r√©gions √©cologiques sont difficiles √† identifier dans les mod√®les Superficie orphelines dans les mod√®les Optimisation du NEP (02751) Les sc√©narios sont non spatiaux MAX_OVOLTOTREC: D√©termination MAX_OAAM: Optimisation de l\u0026rsquo;accroissement annuel moyen MAX_NEP_GLOBAL: Optimisation du bilan (IA) Optimisation du NEP (02751) Constats Le sc√©nario MAX NEP a le meilleur bilan carbone Le sc√©nario MAX AAM stock plus de carbone dans les diff√©rents r√©servoirs Conclusion On peut maintenant obtenir un bilan de carbone facilement pour: Une solution spatiale explicite et spatialement r√©f√©renc√©e Les cinq principaux r√©servoirs de l\u0026rsquo;√©cosyst√®me Les √©missions nettes de l\u0026rsquo;√©cosyst√®me On peut maintenant utiliser le Machine Learning pour: G√©n√©rer des intrants au calcul (Courbes de production, Param√®tres √©conomiques) La g√©n√©ration de solution spatiale avec IA: Nous permettra de faire de l\u0026rsquo;optimisation spatialement explicite Utilisation du projet de fin d\u0026rsquo;√©tude √† B. Forest Replanification spatialement explicite Les prochaines √©tapes Validation de l\u0026rsquo;impact de l\u0026rsquo;optimisation du NEP sur Le choix des travaux sylvicoles La productivit√© Les rotations Faire d\u0026rsquo;autres analyses (UA du sud) Faire un sc√©nario de maximisation des puits de carbone G√©n√©rer une base de donn√©e contenant les actions: Feux R√©cup√©ration apr√®s feux Tester le tout en replanification Des Questions? Github | Documentation\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"fr","lastmod":-62135596800,"objectID":"c10ee181665c4e905d333da7977a672e","permalink":"https://bureau-du-forestier-en-chef.github.io/FMTdocs/fr/slides/fmt_carbone_2023/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/FMTdocs/fr/slides/fmt_carbone_2023/","section":"slides","summary":"Comprendre le projet d'IA","tags":["Machine learning","FORAC","carbon"],"title":"Planification avec Machine Learning (Mise √† jour 2023)","type":"slides"},{"authors":["Guillaume Cyr,ing.f.,M.Sc."],"categories":[],"content":"FMT et d√©veloppements, mise √† jour √©t√© 2023 Github | Documentation\nPlan de la pr√©sentation Pr√©sentation de FMT G√©n√©ration de calendriers de COS Replanification Intelligence artificielle (machine learning) Chronologie des travaux entam√©s Planification 0-6 mois Planification 1-5 ans Questions Qu\u0026rsquo;est-ce que FMT ? librairie open source objets et fonctions en C++, R ou Python graph TD;\r2--\u003e14;\r1--\u003e2--\u003e5;\r1--\u003e3--\u003e6;\r1--\u003e4--\u003e7;\r3--\u003e8;\r3--\u003e12;\r3--\u003e15;\r4--\u003e13;\r5--\u003e9;\r5--\u003e10;\r5--\u003e11;\r1[\"FMT API\"];\r2[\"C++\"];\r3[\"Python\"];\r4[\"Cran R\"];\r5[\"Interface\"];\r6[\"Re-planification\"];\r7[\"Base de donn√©es\"];\r8[\"BFEC-GCBM\"];\r9[\"Planification\"];\r10[\"Spatialisation\"];\r11[\"BFECOPT\"];\r12[\"Analyses diverses\"];\r13[\"Autre\"];\r14[\"Tests\"];\r15[\"Machine Learning\"];\rclassDiagram\rFMTobject \u003c|-- FMTmodel\rFMTmodel \u003c|-- FMTsemodel\rFMTsemodel \u003c|-- FMTsamodel\rFMTsemodel \u003c|-- FMTsesmodel\rFMTmodel \u003c|-- FMTsrmodel\rFMTsrmodel \u003c|-- FMTlpmodel\rFMTsrmodel \u003c|-- FMTnssmodel\rA quoi sert FMT ? planification foresti√®re Comment r√©colter des for√™ts pour maximiser des objectifs (e.g. rendement) ? Sous certaines contraintes (e.g. legislation, technologie, etc.) En pratique, a quoi ca sert ? Lecture de mod√®les Woodstock Simulation de paysages forestiers Optimisation / R√©optimisation de mod√®les Planification (en utilisant des √©v√©nements stochastiques) R√©solution des heuristiques d\u0026rsquo;agr√©gation Planification des blocs de r√©colte Comment est-ce que √ßa marche ? Code source en c++ Compilation en Python et R Interface de programmation (C++)Interface de programmation (C+\u0026hellip;RRPython 2Python 2Python 3Python 3Text is not SVG - cannot display\nPourquoi FMT ? Projet du Bureau du Forestier en Chef du Qu√©bec.\n2017 : Besoin d\u0026rsquo;automatiser l\u0026rsquo;utilisation de mod√®les Woodstocks 2018 : Besoin de relier Woodstock √† GCBM pour estimations de carbone 2019 √† aujourd\u0026rsquo;hui : Augmentation des performances et fonctionalit√©s Planification des Compartiments d\u0026rsquo;Organisation Spatiale (COS) BFECOpt/FMT Documentation COS\nBilan carbone avec l\u0026rsquo;IA stateDiagram\rdirection LR\rstate IA_par_pixel {\rdirection LR\rstate Intrants {\rdirection LR\rDerni√®res_perturbations\rVolume_de_feuillus_tol√©rants\rVolume_de_feuillus_intol√©rants\rVolume_de_r√©sineux\r}\rIntrants --\u003e R√©servoir\rstate R√©servoir {\rBiomasse_a√©rienne\rBiomasse_souterraine\rBois_mort\rCarbone_du_sol\rLiti√®re\r}\rIntrants --\u003e Flux\rState Flux {\rProductivit√©_nette_de_l'√©cosyst√®me\r}\r}\rIA_par_pixel --\u003e Entrainement\rState Entrainement {\rdirection LR\rCPF2328 --\u003e Global\rCPF2328 --\u003e Pessi√®re\rCPF2328 --\u003e Sapini√®re\rCPF2328 --\u003e √ârabli√®re\r}\rEntrainement --\u003e Validation\rState Validation {\rdirection LR\rSpatial --\u003e 07152\rNon_Spatial --\u003e 07152\rSpatial --\u003e 02751\rNon_Spatial --\u003e 02751\rSpatial --\u003e 08665\rNon_Spatial --\u003e 08665\rSpatial --\u003e 08762\rNon_Spatial --\u003e 08762\rSpatial --\u003e 09751\rNon_Spatial --\u003e 09751\r}\rPlanification spatiale par IA stateDiagram\rdirection LR\rMod√®le --\u003e FMTsamodel\rstate FMTsamodel {\rdirection LR\rstate Intrants {\rdirection LR\r(i)Cellule --\u003e √Çge\r(i)Cellule --\u003e Op√©rabilit√©\r(i)Globale --\u003e Taille_des_blocs\r(i)Globale --\u003e D√©lai_d'adjacence\r}\rIntrants --\u003e IA\rstate G√©n√©rateur {\rdirection LR\rCalcul_2328 --\u003e Apprentisage\r}\rState IA {\rG√©n√©rateur --\u003e Pr√©diction\rstate Pr√©diction {\r(o)Spatiaux --\u003e Blocs_de_coupes\r(o)Non_spatiaux --\u003e faisabilit√©\r(o)Non_spatiaux --\u003e Bilan_carbone\r}\r}\rIA --\u003e Optimisation\rState Optimisation {\rValidation --\u003e Am√©lioration\r}\r}\rFMTsamodel --\u003e Solution\rLes objectifs Obtention du bilan de carbone rapidement (Article #1) Tous les r√©servoirs de l‚Äô√©cosyst√®me La productivit√© nette de l‚Äô√©cosyst√®me G√©n√©ration de planification spatialement explicite (Article #2) Maximisant le bilan carbone gantt\rdateFormat YYYY-MM-DD\rtitle Projet FORAC\rexcludes weekends\rsection IA estimateur carbone\rScript d'entrainement :done,des1,2021-04-01,2021-09-01 Script d'utilisation : done,des2,2021-04-01,2021-09-01\rS√©lection du mod√®le : done,des2,2021-04-01,2021-05-01\rRapport : done,des3,2021-09-01,2021-10-01\rInstallation FMT release :done,des4,2021-10-01,2021-11-01\rPytorch √† C++ : done,des5, 2021-10-01,2021-12-01\rInstallation FMT debug : done,des6, 2021-12-01,2022-03-01\rImpl√©mentation : done,des8, 2021-12-01,2022-03-01\r√âcriture de l'article estimateur de carbone\t:des16,2022-09-01,2023-04-01\rTest et validation avec mod√®les r√©els\t:active,des15,2022-10-01,2023-05-01\rsection IA Planification spatiale\rTest et extension √† la planification r√©f√©renc√©e : done,des9, 2022-02-01,2022-05-01\rMise en place d'un plan : done,des10, 2021-12-01,2022-02-01\rLien FMT avec Python avec exemple : done,des11, 2022-01-01,2022-04-01\rMod√®le IA de spatialisation mim√©tique:\tdone,des12, 2022-04-01,2022-10-01\rMod√®le IA d'√©valuation de planification spatialis√©e :done,des13,2022-09-01,2023-03-01\rMod√®le IA de spatialisation (avec carbone) :done,des14,2023-02-01,2023-08-01\r√âcriture de l'article planification foresti√®re\t:crit,des17,2023-04-01,2023-08-01\rConstats IA vs GCBM On peut maintenant obtenir un bilan de carbone facilement pour: Une solution spatiale explicite et spatialement r√©f√©renc√©e Les cinq principaux r√©servoirs de l\u0026rsquo;√©cosyst√®me Les √©missions nettes de l\u0026rsquo;√©cosyst√®me On peut maintenant utiliser le Machine Learning pour: G√©n√©rer des intrants au calcul (Courbes de production, Param√®tres √©conomiques) La g√©n√©ration de solution spatiale avec IA: Nous permettra de faire de l\u0026rsquo;optimisation spatialement explicite Utilisation du projet de fin d\u0026rsquo;√©tude √† B. Forest Replanification spatialement explicite gantt\rdateFormat YYYY-MM-DD\rtitle Travaux entam√©s\rexcludes weekends\rsection Replanification\rD√©veloppement :done, 2023-01-23,2023-05-22\rSupport travaux (F.S, L-A.G, A.B-R) : ,2023-01-09,2023-12-27 section Interface\rD√©ploiement :done, 2023-01-09,2023-01-10\rPr√©sentation :done, 2023-03-13,2023-03-14\rDocumentation :done, 2023-04-03,2023-04-10\rMise en place d'un comit√© FMT : ,2023-05-1,2023-11-07\rBFEC-GCBM, mises √† jour de FMT :en cours, 2023-07-10,2023-08-28\rsection G√©n√©ration de calendriers de COS\rInt√©gration des fonctions du chantier COS : en cours, 2023-04-17,2023-12-27\rsection IA\rMod√®les global et par sous-domaines d'int√©ligence artificielle :done,2023-01-09,2023-05-01\rTests IA :en cours,2023-04-03,2023-08-28 Entretien et d√©bogage : ,2023-01-02,2023-12-27\rSupport : ,2023-01-02,2023-12-27\r√âtapes de la replannification (0-6 mois) gantt\rdateFormat YYYY-MM-DD\rtickInterval month\raxisFormat %b%d\rtitle Planification 0-6 mois\rexcludes weekends\rsection Carbone\rUtilisation de l'IA pour l'obtention d'un bilan carbone : ,2023-12-18,2024-01-01\rsection Analyses\rSupport et transfert aux analystes : , 2023-08-07,2024-01-01\rDocumentation\n√âtapes de l\u0026rsquo;IA (0-6 mois) gantt\rdateFormat YYYY-MM-DD\rtickInterval month\raxisFormat %b%d\rtitle Planification 0-6 mois\rexcludes weekends\rsection IA Carbone\rOptimisation NEP, :active, des1, 2023-05-26,2023-07-24\rOptimisation des Stocks de Carbone\t:active, des1, 2023-05-26,2023-07-24\rOptimisation AAM 2751 (sc√©nario de r√©f√©rence) :active, des1, 2023-06-26,2023-07-24\rOptimisation stock de carbone for√™t feuillue - UA 7152 : des1, 2023-07-14,2023-09-28\rAnalyses des diff√©rents sc√©narios d'optimisation : des1, 2023-08-17,2023-09-28\rApprentissage avec perturbations naturelles : des1, 2023-09-04,2023-12-18\rD√©veloppement pour l'op√©rationalisation du calcul : ,2023-09-04,2024-01-01\rTest de l'op√©rationalisation : ,2023-10-06,2024-01-01\rDocumentation Machine Learning\nInterface (0-6 mois) gantt\rdateFormat YYYY-MM-DD\rtickInterval month\raxisFormat %b%d\rtitle Planification 0-6 mois\rexcludes weekends\rsection SSP\rAnalyses de mod√®les de base : ,2023-08-17,2024-01-01\rsection Spatialisation\rAjout du Simulated Annealing : ,2023-10-16,2024-01-01\rsection Calendrier de COS\rInt√©gration des fonctions du chantier COS : en cours, 2023-04-17,2023-12-27\rLES FUTURS PROJETS (0-5 ans) GCBM\nMise √† jour de GCBM Refonte des scripts en Python3 Int√©gration des produits du bois Spatialisation du calcul\nD√©veloppement d\u0026rsquo;un indice caribou D√©veloppement d\u0026rsquo;un indice de r√©seau routier Visualisation de solutions alternatives LES FUTURS PROJETS (0-5 ans) Gestion des mod√®les de base\nAutomatisation des validations Automatisation d\u0026rsquo;analyses pr√©liminaires Replanification spatialement explicite\nPermettre d‚Äôobtenir un effet de spatialisation √† travers la replanification Utilisation d‚Äô√©v√®nements stochastiques spatiaux Inclure les enjeux op√©rationels Changements climatiques Continuer/faire un transfert de connaissances aux diff√©rents services\nDes Questions? Github | Documentation\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"fr","lastmod":-62135596800,"objectID":"c7b69bf903c4088d80cd34168ab1d503","permalink":"https://bureau-du-forestier-en-chef.github.io/FMTdocs/fr/slides/rencontre_250723/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/FMTdocs/fr/slides/rencontre_250723/","section":"slides","summary":"Comprendre le projet d'IA","tags":["Machine learning","FORAC","FMT"],"title":"Planification des d√©veloppements FMT","type":"slides"},{"authors":["Guillaume Cyr,ing.f.,M.Sc."],"categories":[],"content":"Planification foresti√®re √† l‚Äôaide du Machine Learning Github | Documentation\nProbl√©matique Notre bilan carbone est difficile √† obtenir rapidement Pour tous les r√©servoirs de l\u0026rsquo;√©cosyst√®me Carbone du sol Biomasse souterraine Liti√®re Bois mort Biomasse a√©rienne Pour la productivit√© nette de l\u0026rsquo;√©cosyst√®me Probl√©matique La localisation des activit√©s sylvicoles pouvant am√©liorer le bilan carbone est un enjeu complexe Le calcul du bilan de carbone forestier pour un mod√®le de planification est complexe L‚Äôoptimisation spatialement explicite de la localisation des travaux sylvicoles peut √™tre tr√®s difficile √† r√©aliser avec un mod√®le math√©matique classique Productivit√© nette de l‚Äô√©cosyst√®me Productivit√© nette de l‚Äô√©cosyst√®me Probl√©matique: Productivit√© nette de l‚Äô√©cosyst√®me ? Probl√©matique: √âtat des r√©servoirs ? Probl√©matique: √âtat des r√©servoirs ? Probl√©matique: √âtat des r√©servoirs ? Probl√©matique:‚Ä¶Pour chaque p√©riode Objectif Obtention du bilan de carbone rapidement Tous les r√©servoirs de l‚Äô√©cosyst√®me Carbone du sol Biomasse souterraine Liti√®re Bois mort Biomasse a√©rienne La productivit√© nette de l‚Äô√©cosyst√®me Donn√©es d\u0026rsquo;apprentissage Apprentissage r√©alis√© Utilisation de la m√©thode Utilisation de la m√©thode Concr√®tement Nouvelle syntaxe pour la section yield Voir dans examples/Models/TWD_land/Scenarios/Predictors D√©veloppement d\u0026rsquo;un nouveau type de yield \u0026ldquo;*YM\u0026rdquo; Mod√®le pour les r√©servoirs {\rIntrants:\r- GFI = Volume de feuillus intol√©rants\r- GFT = Volume de feuillus tol√©rants\r- GF = Volume feuillu total\r- GR = Volume r√©sineux total\r}\r*YM ? ? ?\rAG_Biomass_C,BG_Biomass_C,Deadwood_C,Litter_C,Soil_C _PRED(pools_carbon,GFI,GFT,GF,GR)\r{\rExtrants:\r- AG_Biomass_C = Biomasse a√©rienne\r- BG_Biomass_C = Biomasse souterraine\r- Deadwood_C = Bois mort\r- Litter_C = Litti√®re\r- Soil_C = Sol\r}\rMod√®le pour la productivit√© nette de l\u0026rsquo;√©cosyst√®me {\rIntrants:\r- GFI = Volume de feuillus intol√©rants\r- GFT = Volume de feuillus tol√©rants\r- GF = Volume feuillu total\r- GR = Volume r√©sineux total\r}\r*YM ? ? ?\rNEP _PRED(nep_carbon,GFI,GFT,GF,GR)\r{\rExtrants:\r- AG_Biomass_C = Biomasse a√©rienne\r- BG_Biomass_C = Biomasse souterraine\r- Deadwood_C = Bois mort\r- Litter_C = Litti√®re\r- Soil_C = Sol\r}\rSuivi des variables ;Inventaire de la productivit√© nette de l'√©cosyst√®me en (c)\r*OUTPUT NEP_Total\r*SOURCE ? ? ? _INVENT NEP\r;Inventaire de la biomasse a√©rienne et souterraine en (c)\r*OUTPUT Biomasse_Total\r*SOURCE ? ? ? _INVENT AG_Biomass_C + ? ? ? _INVENT BG_Biomass_C\r;Inventaire du carbone du sol en (c)\r*OUTPUT Sols_Total\r*SOURCE ? ? ? _INVENT Soil_C\rProbl√©matique : Optimisation spatialement explicite Pratiquement impossible avec nos mod√®les Utilisation d‚Äôune heuristique pour placer la r√©colte Difficile √† obtenir √† moins d‚Äôimpl√©menter une heuristique: Simulated Annealing Tabou Search Utilisation de la programmation mixte int√©grale On peut donc difficilement r√©pondre √† la question du o√π doit t‚Äôon faire tel ou tel traitement pour am√©liorer notre bilan de carbone Objectif : Meilleur bilan Objectif : Meilleur bilan Objectif : Meilleur bilan et respect des contraintes Objectif : Meilleur bilan et respect des contraintes Apprentissage Apprentissage Conclusion On peut maintenant obtenir un bilan de carbone facilement pour:\nUne solution spatiale explicite et spatialement r√©f√©renc√©e Les cinqs principaux r√©servoirs de l\u0026rsquo;√©cosyst√®me Le flux de productivit√© nette de l\u0026rsquo;√©cosyst√®me On peut maintenant utiliser le Machine Learning pour:\nG√©n√©rer des solutions spatialement explicites plausibles Am√©liorer notre planification en fonction de notre bilan de carbone Des Questions? Github | Documentation\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"fr","lastmod":-62135596800,"objectID":"6365364d9505913f505ba194a81e1570","permalink":"https://bureau-du-forestier-en-chef.github.io/FMTdocs/fr/slides/fmt_carbone/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/FMTdocs/fr/slides/fmt_carbone/","section":"slides","summary":"Comprendre ce que FMT est, et ce qu'il fait.","tags":["Machine learning","FORAC","carbon"],"title":"Planification foresti√®re √† l‚Äôaide du Machine Learning","type":"slides"}]